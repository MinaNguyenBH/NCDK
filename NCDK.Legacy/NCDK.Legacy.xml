<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NCDK.Legacy</name>
    </assembly>
    <members>
        <member name="T:NCDK.Isomorphisms.Matchers.CTFileQueryBond">
            <summary>
            Captures query bond types defined in the CTFile.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.CTFileQueryBond.BondType">
            <summary>
            Bond types, as stated in the CTFile manual
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.CTFileQueryBond.Type">
            <summary>
            The type of this bond.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.CTFileQueryBond.OfType(NCDK.IBond,System.Int32)">
            <summary>
            Create a CTFileQueryBond of the specified type (from the MDL spec). The
            bond copies the atoms and sets the type using the value 'type', 5 = single
            or double, 8 = any, etc.
            </summary>
            <param name="bond">an existing bond</param>
            <param name="type">the specified type</param>
            <returns>a new CTFileQueryBond</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom">
            <summary>
            A QueryAtom that matches all symbols but those in this container. You may
            add symbols to this container. This QueryAtom will only give a match if it
            does NOT contain the symbol of the Atom to match (example: add "C" to get a
            match for all non-"C"-Atoms).
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.#ctor">
            <summary>
             Constructor for the InverseSymbolSetQueryAtom object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.Matches(NCDK.IAtom)">
            <summary>
             The matches implementation of the <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/> interface.
            </summary>
            <param name="atom">The atom to be matched by this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/></param>
            <returns>true if Atom matched</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.AddSymbol(System.String)">
            <summary>
             Add a symbol to this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/>
            </summary>
            <param name="symbol">The symbol to add</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.RemoveSymbol(System.String)">
            <summary>
            Remove a symbol from this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/>
            </summary>
            <param name="symbol">The symbol to remove</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.HasSymbol(System.String)">
            <summary>
            Check whether a symbol is already registered
            </summary>
            <param name="symbol">The symbol to check for</param>
            <returns>true if symbol already registered</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.GetSymbolSet">
             <summary>
             Retrieve the Set of symbols
            
             <returns>The symbol Set</returns>
             </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom.ToString">
            <summary>
             The ToString method
            </summary>
            <returns>The string representation of this object.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.OrderQueryBondOrderOnly">
            <summary>
            <see cref="T:NCDK.Isomorphisms.Matchers.IQueryBond"/> that matches IBond object only based on bond order, and
            disregarding any aromaticity flag.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticAtom">
            <summary>
            This matcher any non-aromatic atom. This assumes that aromaticity in the
            molecule has been perceived.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticAtom.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticSymbolAtom">
            <summary>
            This smarts atom matches aliphatic atom with element symbol specified.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AliphaticSymbolAtom.#ctor(System.String)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="symbol">the atom symbol</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AnyAtom">
            <summary>
            This matcher any Atom including explicit hydrogens.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AnyAtom.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AnyOrderQueryBond">
            <summary>
            This matches a bond of any order.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AnyOrderQueryBond.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.BondOrder)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="atom1"></param>
            <param name="atom2"></param>
            <param name="order"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticAtom">
            <summary>
            This matcher any aromatic atom. This assumes that aromaticity in the molecule
            has been perceived.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticAtom.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond">
            <summary>
            This matches an aromatic or a single bond, used when no bond is specified between an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond.#ctor">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AromaticOrSingleQueryBond.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.BondOrder)">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticQueryBond">
            <summary>
            This matches an aromatic bond.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AromaticSymbolAtom">
            <summary>
            This class matches aromatic atom with element symbol specified.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.AtomicNumberAtom">
            <summary>
            This matches an atom using the atomic number.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.AtomicNumberAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="atomicNumber"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom">
            <summary>
            This matches an atom with chirality property. It is not implemented yet.
            It'll match any atom right now.
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.Degree">
            <summary>
            The degree of the chirality
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.IsUnspecified">
            <summary>
            Whether unspecified chirality should be taken into consideration
            </summary>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.IsClockwise">
            <summary>
            Whether the chirality is clockwise
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ChiralityAtom.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom">
            <summary>
            Match an atom with the defined degree. The degree is also referred to as the
            explicit connectivity and is encoded in smarts using "D&lt;NUMBER&gt;".
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.degree">
            <summary>Number of explicit connections.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.#ctor(System.Int32)">
            <summary>
            Create a query atom for matching the degree of an atom. The degree is the
            number connected atoms.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ExplicitConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.FormalChargeAtom">
            <summary>
            This matcher checks the formal charge of the Atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.FormalChargeAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="charge"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.HybridizationNumberAtom">
            <summary>
            This matcher checks the hybridization state of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.HybridizationNumberAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="hybridizationNumber">the hybridiation</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.HydrogenAtom">
            <summary>
            This matches Hydrogen atoms.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.HydrogenAtom.#ctor">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ImplicitHCountAtom">
            <summary>
            This matcher checks the number of implicit hydrogens of the Atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.ImplicitHCountAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="hcount"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom">
            <summary>
            This class matches a logical operator that connects two query atoms. Logical
            matchers are created with,  <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.And(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)"/>, 
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Not(NCDK.Isomorphisms.Matchers.IQueryAtom)"/> and <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Or(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)"/>.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.left">
            <summary>Left child</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.operator_">
            <summary>Name of operator</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.right">
            <summary>Right child</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Matches(NCDK.IAtom)">
            <summary>
            </summary>
            <param name="atom"></param>
            <returns></returns>
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Matches(NCDK.IAtom)"/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.And(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Conjunction the provided expressions.
            </summary>
            <param name="left">expression</param>
            <param name="right">expression</param>
            <returns>conjunction of the left and right expressions</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Or(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Disjunction the provided expressions.
            </summary>
            <param name="left">expression</param>
            <param name="right">expression</param>
            <returns>disjunction of the left and right expressions</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Not(NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Negate the provided expression.
            </summary>
            <param name="expr">expression to negate</param>
            <returns>a SMARTS atom which is the negation of the expression</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction">
            <summary>Defines a conjunction (AND) between two query atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.left">
            <summary>left and right of the operator.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.right">
            <summary>left and right of the operator.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a disjunction of <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.Left"/> or <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.right"/>.
            </summary>
            <param name="left">the expression to negate</param>
            <param name="right">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Conjunction.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction">
            <summary>Defines a disjunction (or) between two query atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.left">
            <summary>left of the operator.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.right">
            <summary>right of the operator.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a disjunction of <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.Left"/> or <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.right"/>.
            </summary>
            <param name="left">the expression to negate</param>
            <param name="right">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Disjunction.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation">
            <summary>Defines a negation (not) of a query atom.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.expression">
            <summary>Expression to negate.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.chiral">
            <summary>Is the expression chiral - if so, always true!</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom)">
            <summary>
            Create a negation of <paramref name="expression"/>.
            </summary>
            <param name="expression">the expression to negate</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorAtom.Negation.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond">
            <summary>
            This class matches a logical operator that connects two query bonds.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.left">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.operator_">
            <summary>
            Name of the operator
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.LogicalOperatorBond.right">
            <summary>
            Right child
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.MassAtom">
            <summary>
            This class matches an atom based on the atomic mass.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.MassAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="mass"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.NonCHHeavyAtom">
            <summary>
            This matcher any heavy atom that is not C or H.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.NonCHHeavyAtom.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.OrderQueryBond">
            <summary>
            This matches a bond with a certain bond order.
            </summary>
            <remarks>
            Daylight spec indicates that if match a single bond
            using '-', it should be an aliphatic single bond
            </remarks>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.OrderQueryBond.#ctor(NCDK.BondOrder)">
            <summary>
            Creates a new instance
            </summary>
            <param name="order">the order of bond</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.PeriodicGroupNumberAtom">
            <summary>
            This matcher checks the periodic group number of an atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.PeriodicGroupNumberAtom.#ctor(System.Int32)">
            <summary>
            Creates a new instance
            </summary>
            <param name="groupNumber">the periodic group number</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.ReactionRoleQueryAtom">
            <summary>
            Matches atoms with a particular role in a reaction.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom">
            <summary>
            This matches recursive smarts atoms.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.query">
            <summary>The IQueryAtomContainer created by parsing the recursive smarts</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.cache">
            <summary>Query cache.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RecursiveSmartsAtom.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Creates a new instance
            </summary>
            <param name="query"></param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingBond">
            <summary>
            This smarts bond matches any bond that is in a ring.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingBond.#ctor">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingIdentifierAtom">
            <summary>
            This encapsulates an atom with a ring identifier, with an optional ring
            bond specified. For example, "C=1CCCCC1".
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom">
            <summary>
            This query is found in a specified number of ring. The ring membership is
            specified with the SMARTS "R&lt;NUMBER&gt;". The membership depends on the
            ring set used and as such is not a portable term. If the Smallest Set of
            Smallest Rings (SSSR) is used then changing the order of atoms
            <i>may</i> change which atoms match in a pattern.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.ringNumber">
            <summary>
            Number of rings to which this atom belongs, if &lt; 0 check any ring
            membership.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.#ctor(System.Int32)">
            <summary>
            Ring membership query atom. Check if the an atom belongs to <i>num</i> of
            rings. To specify any ring membership, <i>num</i> should be specified as
            &lt; 0. Generally in SMARTS it's better negate ring membership with "[!R]"
            however for legacy reasons "[R0]" was accepted and checks
            this atoms belongs to 0 rings.
            </summary>
            <param name="num">number of rings which this atom belongs to, &lt; 0 any ring.</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.RingMembershipAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom">
            <summary>
            Match an atom in a specific size ring. The ring size is specified by "r&lt;NUMBER&gt;"
            in a SMARTS pattern. This term is non-portable, depending on the
            set of rings chosen and which ring sizes are used. The default implementation
            (Daylight) only stores the smallest ring each atom belongs to whilst other
            implementations may store multiple values. A more portable term is the
            ring connectivity which is specified as "x&lt;NUMBER&gt;".
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.ringSize">
            <summary>Ring size to check.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.#ctor(System.Int32)">
            <summary>
            Creates a matcher for specified ring size.
            </summary>
            <param name="ringSize">size of the ring to check.</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmallestRingAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom">
            <summary>
            Abstract smarts atom.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Invariants(NCDK.IAtom)">
            <summary>
            Access the atom invariants for this atom. If the invariants have not been
            set an exception is thrown.
            </summary>
            <param name="atom">the atom to obtain the invariants of</param>
            <returns>the atom invariants for the atom</returns>
            <exception cref="T:System.NullReferenceException">thrown if the invariants were not set</exception>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.ChiralityMatches(NCDK.IAtom,System.Int32,System.Int32)">
             <summary>
             Check if the atom-based chirality of the target matches. This check is
             done post-matching and should only be checked on atoms which are know to
             have already been matched (<see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom.Matches(NCDK.IAtom)"/>).
            
             Currently the only atom-based chirality allowed is tetrahedral stereo-chemistry. 
             </summary>
             <param name="target">the matched target (required to verify 'OR' conditions)</param>
             <param name="tParity">the parity (winding) of the target centre, 0=unspecified, 1=clockwise and -1=anticlockwise</param>
             <param name="permParity">permutation parity of the query neighbors (will be multiplied by the query parity)</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants">
            <summary>
            Computes and stores atom invariants in a single object. The atom invariants
            are utilised as additional information for the <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom"/>s to match.
            The values provide additional invariants which are not defined in the <see cref="T:NCDK.IAtom"/> 
            API and avoids storing multiple properties in a type unsafe map
            (<see cref="M:NCDK.IChemObject.SetProperty(System.Object,System.Object)"/>). 
            </summary>
            <remarks>
            <para>Depending on the SMARTS
            implementation different values for the ring information may be set. The
            choice of ring set affects <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingNumber"/> and <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize"/> .
            Some implementations store all ring sizes whilst others (Daylight) store only
            the smallest. The <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Degree"/>  also depends on whether hydrogens are
            suppressed or represented as explicit atoms. </para>
            <para>The <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)"/> and
            <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)"/>
            static utilities create
            and set the invariants following the Daylight implementation. The invariants
            are set on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/>  property of each atom.
            </para>
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key">
            <summary>Property key to index the class by.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.target">
            <summary>the molecule which this atom belongs.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.valence">
            <summary>Total number of bonds formed - also refereed to as bond order sum.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringNumber">
            <summary>The number of rings this atom can be found in.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringSize">
            <summary>The size of rings an atom is found in.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.connectivity">
            <summary>Total number of connected atoms including implicit hydrogens.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ringConnectivity">
            <summary>Total number of connected ring bonds.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.degree">
            <summary>Total number of explicitly connected atoms.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.totalHydrogenCount">
            <summary>The total number of hydrogens on an atom.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.#ctor(NCDK.IAtomContainer,System.Int32,System.Int32,System.Collections.Generic.ICollection{System.Int32},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Internal constructor - simple takes all the values.
            </summary>
            <param name="valence">the valence value</param>
            <param name="ringNumber">number of rings an atom belongs to (variable)</param>
            <param name="ringSize">the size of the rings (variable)</param>
            <param name="ringConnectivity">the number of connected ring bonds (or atoms)</param>
            <param name="degree">the degree of an atom</param>
            <param name="connectivity">the number of connections (degree + implicit H count)</param>
            <param name="totalHydrogenCount">the total number of hydrogens</param>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Valence">
            <summary>
            Access the valence of this atom. The valence is matched by the "v&lt;NUMBER&gt;"
            SMARTS token. The valence is the total number of bonds formed
            by this atom and <b>NOT</b> the number of valence electrons. As such
            "[v3]" will match a 3 valent nitrogen and "[v5]" will match a
            5 valent nitrogen. The value is separate from <see cref="P:NCDK.IAtomType.Valency"/> 
            so it can be cleaned up after matching and avoid confusion with what the
            value should be.
            </summary>
            <returns>the valence of the atom.</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingNumber">
            <summary>
            The number of rings this atom belong to. The value is matched by the
            "R&lt;NUMBER&gt;" token and depends on the ring set used. The Daylight
            implementation uses the non-unique Smallest Set of Smallest Rings (SSSR)
            which can lead to inconsistent matches.
            </summary>
            <returns>number or rings</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize">
            <summary>
            The sizes of rings this atoms belongs to. The value is matched by the
            "r&lt;NUMBER&gt;" token and depends on the ring set used. The Daylight
            implementation uses this value to match the smallest ring to which this
            atom is a member. It may be beneficial to match multiple ring sizes (not
            yet defined by OpenSMARTS).
            </summary>
            <returns>ring sizes</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingConnectivity">
            <summary>
            The number of connected ring bonds (or atoms). This value is matched by
            the "x&lt;NUMBER&gt;" token. The Daylight implementation counts the
            number of connected ring bonds but it may be beneficial to match the atom
            ring connectivity (not yet defined by OpenSMARTS).
            </summary>
            <returns>ring connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Connectivity">
            <summary>
            The number of connected bonds including those to hydrogens. This value is
            matched by the "X&lt;NUMBER&gt;" token. This value depends on whether the
            hydrogens have been suppressed or are represented as explicit atoms.
            </summary>
            <returns>connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Degree">
            <summary>
            The degree of a vertex defined as the number of explicit connected bonds.
            This value is matched by the "D&lt;NUMBER&gt;" token. This value depends
            on whether the hydrogens have been suppressed or are represented as
            explicit atoms.
            </summary>
            <returns>connectivity</returns>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.TotalHydrogenCount">
            <summary>
            The total number of hydrogens attached to an atom.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)">
            <summary>
            Computes <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/> and stores on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/> or
            each <see cref="T:NCDK.IAtom"/> in the <paramref name="container"/>. The <see cref="P:NCDK.IMolecularEntity.IsInRing"/>  
            is also set for each bond. This configuration does
            not include ring information and values are left as unset.
            Ring membership is still configured but not ring size.
            </summary>
            <example>
            <code>
                IAtomContainer container = ...;
                SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(container);
                foreach (var atom in container.Atoms) {
                    SMARTSAtomInvariants inv = atom.GetProperty&lt;SMARTSAtomInvariants&gt;(SMARTSAtomInvariants.Key);
                }
            </code>
            </example>
            <param name="container">the container to configure</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)">
            <summary>
            Computes <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/> and stores on the <see cref="F:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.Key"/> or
            each <see cref="T:NCDK.IAtom"/> in the <paramref name="container"/>. The <see cref="P:NCDK.IMolecularEntity.IsInRing"/>  
            is also set for each bond. This configuration
            includes the ring information as used by the Daylight implementation.
            That is the Smallest Set of Smallest Rings (SSSR) is used and only the
            smallest ring is stored for the <see cref="P:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.RingSize"/> .
            </summary>
            <example>
            <code>
                IAtomContainer container = ...;
                SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(container);
                foreach (var atom in container.Atoms) {
                    SMARTSAtomInvariants inv = atom.GetProperty&lt;SMARTSAtomInvariants&gt;(SMARTSAtomInvariants.Key);
                }
            </code>
            </example>
            <param name="container">the container to configure</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylight(NCDK.IAtomContainer,System.Int32[][],NCDK.Graphs.EdgeToBondMap,System.Boolean)">
            <summary>
            Computes invariants - see <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithRingInfo(NCDK.IAtomContainer)"/> 
            and <see cref="M:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants.ConfigureDaylightWithoutRingInfo(NCDK.IAtomContainer)"/>.
            </summary>
            <param name="container">the container to configure</param>
            <param name="graph">the graph for quick traversal</param>
            <param name="bondMap">the bond map for quick bond lookup</param>
            <param name="ringInfo">logical condition as whether ring info should be included</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSBond">
            <summary>
            Abstract smarts bond.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.SmartsMatchers">
            <summary>
            Bridging class between the SMARTS matcher and the parser/query tool. The
            class are currently split across different packages. This classes temporary
            functionality is to expose package private functionality through a single
            location.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.SmartsMatchers.Prepare(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Do not use - temporary method until the SMARTS packages are cleaned up.
            </summary>
            <remarks>
            Prepares a target molecule for matching with SMARTS.
            </remarks>
            <param name="container">the container to initialise</param>
            <param name="ringQuery">whether the smarts will check ring size queries</param>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.StereoBond">
            <summary>
            This query bond indicates a particular geometric stereo configuration.
            </summary>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom">
            <summary>
            This matches an atom using total number of connections - referred to in
            SMARTS as the connectivity. The connectivity is specified using the "X&lt;NUMBER&gt;" pattern.
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.connectivity">
            <summary>Total number of connections from an atom including H count.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.#ctor(System.Int32)">
            <summary>Creates a new instance.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom">
            <summary>
            SMARTS query atom for matching the total hydrogen count. This count is
            specified in SMARTS using "H&lt;NUMBER&gt;".
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.totalHCount">
            <summary>The total hydrogen count to match.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.Matches(NCDK.IAtom)">
            <summary>
            Check if the total hydrogen count of the <paramref name="atom"/> is equal to the
            query.
            </summary>
            <param name="atom">the atom to match</param>
            <returns>the hydrogen count matches</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalHCountAtom.ToString">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom">
            <summary>
            This matcher checks the number of ring connections of the checked Atom with
            other Atom's. This cannot be matched without prepossessing Atom - <see cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtomInvariants"/>.
            The ring connectivity is encoded in smarts using "x&lt;NUMBER&gt;".
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.ringConnectivity">
            <summary>Number of rings.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.#ctor(System.Int32)">
            <summary>
            Create a matcher for the number of rings an atom belongs to.
            </summary>
            <param name="ringConnectivity">number of ring bonds this atom is adjacent to</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalRingConnectionAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom">
            <summary>
            This matcher checks the valence of the Atom. The valence is the number of
            bonds formed by an atom (including bonds to implicit hydrogens).
            </summary>
        </member>
        <member name="F:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.valence">
            <summary>
            The valence to match.
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.#ctor(System.Int32)">
            <summary>
            Match the valence of atom.
            </summary>
            <param name="valence">valence value</param>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SMARTS.TotalValencyAtom.Matches(NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom">
            <summary>
             A QueryAtom that matches all symbols in this container. You may add symbols
             to this container. This QueryAtom will only give a match if it contains the
             symbol of the Atom to match (example: add "F", "Cl", "Br", "I" to get a
             match for the most common halogens).
            </summary>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.InverseSymbolSetQueryAtom"/>
        </member>
        <member name="P:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.Symbols">
            <summary>
            The symbol Set
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.#ctor">
            <summary>
             Constructor for the <see cref="T:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom"/> object
            </summary>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.Matches(NCDK.IAtom)">
            <summary>
            The matches implementation of the <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/> interface.
            </summary>
            <param name="atom">The atom to be matched by this <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtom"/></param>
            <returns>true if Atom matched</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.Matchers.SymbolSetQueryAtom.ToString">
            <summary>
             The ToString method
            </summary>
            <returns>The string representation of this object.</returns>
        </member>
        <member name="T:NCDK.Isomorphisms.SmartsStereoMatch">
            <summary>
            Filters SMARTS matches for those that have valid stereochemistry
            configuration.
            </summary>
            <remarks>
            <note type="note">
            This class is internal and will be private in future.
            </note>
            </remarks>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.query">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.target">
            <summary>Query and target contains.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetMap">
            <summary>Atom to atom index lookup.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetElements">
            <summary>Indexed array of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetTypes">
            <summary>Indexed array of stereo element types.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.queryStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="F:NCDK.Isomorphisms.SmartsStereoMatch.targetStereoIndices">
            <summary>Indices of focus atoms of stereo elements.</summary>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Create a predicate for checking mappings between a provided
            <paramref name="query"/> and <paramref name="target"/>.
            </summary>
            <param name="query">query container</param>
            <param name="target">target container</param>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Apply(System.Int32[])">
            <summary>
            Is the <paramref name="mapping"/> of the stereochemistry in the query preserved in
            the target.
            </summary>
            <param name="mapping">permutation of the query vertices</param>
            <returns>the stereo chemistry is value</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.CheckTetrahedral(System.Int32,System.Int32[])">
            <summary>
            Verify the tetrahedral stereochemistry (clockwise/anticlockwise) of atom
            <paramref name="u"/> is preserved in the target when the <paramref name="mapping"/> is used.
            </summary>
            <param name="u">tetrahedral index in the target</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the tetrahedral configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Map(System.Int32,System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Transforms the neighbors <paramref name="us"/> adjacent to <paramref name="u"/> into the target
            indices using the mapping <paramref name="mapping"/>. The transformation accounts
            for an implicit hydrogen in the query being an explicit hydrogen in the
            target.
            </summary>
            <param name="u">central atom of tetrahedral element</param>
            <param name="v">mapped central atom of the tetrahedral element</param>
            <param name="us">neighboring vertices of <paramref name="u"/> (<paramref name="u"/> plural)</param>
            <param name="mapping">mapping from the query to the target</param>
            <returns>the neighbors us, transformed into the neighbors around v</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.CheckGeometric(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Verify the geometric stereochemistry (cis/trans) of the double bond
            <c><paramref name="u1"/>=<paramref name="u2"/></c> is preserved in the target when the <paramref name="mapping"/> is
            used.
            </summary>
            <param name="u1">one index of the double bond</param>
            <param name="u2">other index of the double bond</param>
            <param name="mapping">mapping of vertices</param>
            <returns>the geometric configuration is preserved</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Neighbors(NCDK.ITetrahedralChirality,System.Collections.Generic.Dictionary{NCDK.IAtom,System.Int32})">
            <summary>
            Access the neighbors of <paramref name="element"/> as their indices.
            </summary>
            <param name="element">tetrahedral element</param>
            <param name="map">atom index lookup</param>
            <returns>the neighbors</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.PermutationParity(System.Int32[])">
            <summary>
            Compute the permutation parity of the values <paramref name="vs"/>. The parity is
            whether we need to do an odd or even number of swaps to put the values in
            sorted order.
            </summary>
            <param name="vs">values</param>
            <returns>parity of the permutation (odd = -1, even = +1)</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.OtherIndex(System.Int32)">
            <summary>
            Given an index of an atom in the query get the index of the other atom in
            the double bond.
            </summary>
            <param name="i">query atom index</param>
            <returns>the other atom index involved in a double bond</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.IndexAtoms(NCDK.IAtomContainer)">
            <summary>
            Create an index of atoms for the provided <paramref name="container"/>.
            </summary>
            <param name="container">the container to index the atoms of</param>
            <returns>the index/lookup of atoms to the index they appear</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.IndexElements(System.Collections.Generic.Dictionary{NCDK.IAtom,System.Int32},NCDK.IStereoElement{NCDK.IChemObject,NCDK.IChemObject}[],NCDK.Isomorphisms.SmartsStereoMatch.StereoType[],NCDK.IAtomContainer)">
            <summary>
            Index the stereo elements of the <paramref name="container"/> into the the 
            <paramref name="elements"/> and <paramref name="types"/> arrays. The <paramref name="map"/> is used for looking
            up the index of atoms.
            </summary>
            <param name="map">index of atoms</param>
            <param name="elements">array to fill with stereo elements</param>
            <param name="types">type of stereo element indexed</param>
            <param name="container">the container to index the elements of</param>
            <returns>indices of atoms involved in stereo configurations</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Parity(NCDK.TetrahedralStereo)">
            <summary>
            Get the parity (-1,+1) of the tetrahedral configuration.
            </summary>
            <param name="stereo">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="M:NCDK.Isomorphisms.SmartsStereoMatch.Parity(NCDK.DoubleBondConformation)">
            <summary>
            Get the parity (-1,+1) of the geometric (double bond) configuration.
            </summary>
            <param name="conformation">configuration</param>
            <returns>the parity</returns>
        </member>
        <member name="T:NCDK.Normalizers.Normalizer">
            <summary>
            Adjusts parts of an AtomContainer to the configuration of a fragment.
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.Normalizer.Normalize(NCDK.IAtomContainer,System.Xml.Linq.XDocument)">
            <summary>
             The method takes an XML files like the following:
             <pre>
             &lt;replace-set&gt;
             &lt;replace&gt;O=N=O&lt;/replace&gt;
             &lt;replacement&gt;[O-][N+]=O&lt;/replacement&gt;
             &lt;/replace-set&gt;
             </pre>
            </summary>
            <remarks>
             All parts in ac which are the same as replace will be changed according to replacement.
             Currently the following changes are done: BondOrder, FormalCharge.
             For detection of fragments like replace, we rely on <see cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester"/>.
             doc may contain several replace-sets and a replace-set may contain several replace fragments, which will all be normalized according to replacement.
             </remarks>
            <param name="ac">The atomcontainer to normalize.</param>
            <param name="doc">The configuration file.</param>
            <returns>Did a replacement take place?</returns>
            <exception cref="T:NCDK.InvalidSmilesException"> doc contains an invalid smiles.</exception>
        </member>
        <member name="T:NCDK.Normalizers.SMSDNormalizer">
            <summary>
            This class containes set of modules required to clean a molecule
            before subjecting it for MCS search. eg. aromatizeMolecule
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.MakeDeepCopy(NCDK.IAtomContainer)">
            <summary>
            Returns deep copy of the molecule
            </summary>
            <param name="container"></param>
            <returns>deep copy of the mol</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.AromatizeMolecule(NCDK.IAtomContainer)">
            <summary>
            This function finds rings and uses aromaticity detection code to
            aromatize the molecule.
            </summary>
            <param name="mol">input molecule</param>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetExplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of explicit hydrogens for a given IAtom.
            </summary>
            <returns>The number of explicit hydrogens on the given IAtom.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetImplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of Implicit Hydrogen Count for a given IAtom.
            </summary>
            <returns>Implicit Hydrogen Count</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.GetHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            The summed implicit + explicit hydrogens of the given IAtom.
            <returns>The summed implicit + explicit hydrogens of the given IAtom.</returns>
            </summary>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.RemoveHydrogensAndPreserveAtomID(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.ConvertExplicitToImplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.Normalizers.SMSDNormalizer.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>. If the
            matcher finds atom matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            <param name="container"></param>
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAliphatic.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAnyAtom.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAromatic.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtom.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTAtomicMass.Mass">
            <summary>
            The mass value.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtomicMass.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTAtomicNumber.Number">
            <summary>
            the atomic number.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTAtomicNumber.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTCharge.Charge">
            <summary>
            The charge value.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTCharge.IsPositive">
            <summary>
            true if charge is positive.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTCharge.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTChirality.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTElement.Symbol">
            <summary>
            the element symbol.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTElement.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTExplicitAtom.Symbol">
            <summary>
            The element symbol.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitAtom.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitConnectivity.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitHighAndBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTExplicitHighAndExpression.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTGroup.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTHybrdizationNumber.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTImplicitHCount.Count">
            <summary>
            Implicit H count.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHCount.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHighAndBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTImplicitHighAndExpression.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTLowAndBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTLowAndExpression.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNonCHHeavyAtom.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNotBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTNotExpression.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTOrBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTOrExpression.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTPeriodicGroupNumber.GroupNumber">
            <summary>
            The periodic table group number for this element.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPeriodicGroupNumber.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression">
            <summary>
            An AST node. It represents one type of atomic primitive notation in smarts.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTPrimitiveAtomExpression.#ctor(NCDK.Smiles.SMARTS.Parser.SMARTSParser,System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTReaction.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingConnectivity.NumOfConnection">
            <summary>
            The number of ring connections.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingConnectivity.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingIdentifier.RingId">
            <summary>
            The ring identifier.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingIdentifier.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTRingMembership.NumOfMembership">
            <summary>
            The number of SSSR rings this atom is in.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTRingMembership.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSimpleBond.BondType">
            <summary>
            Type of bond.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSimpleBond.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSmallestRingSize.Size">
            <summary>
            The smallest SSSR size.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSmallestRingSize.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTSmarts.ComponentId">
            <summary>
            Indicate that component-level grouping should applied and this expression
            belongs to the specified component.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTSmarts.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTTotalConnectivity.NumOfConnection">
            <summary>
            The number of total connections.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTTotalConnectivity.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTTotalHCount.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ASTValence.Order">
            <summary>
            valence order.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ASTValence.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.INode">
            <summary>
            All AST nodes must implement this interface.  It provides basic
            machinery for constructing the parent and child relationships
            between nodes.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtOpen">
            <summary> This method is called after the node has been made the current node.  It indicates that child nodes can now be added to it.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtClose">
            <summary> This method is called after all the child nodes have been added.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtSetParent(NCDK.Smiles.SMARTS.Parser.INode)">
            <summary> This pair of methods are used to inform the node of its parent.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtAddChild(NCDK.Smiles.SMARTS.Parser.INode,System.Int32)">
            <summary> This method tells the node to add its argument to the node's list of children. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtGetChild(System.Int32)">
            <summary> This method returns a child node.  The children are numbered from zero, left to right.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtGetNumChildren">
            <summary>Return the number of children the node has.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.INode.JjtRemoveChild(System.Int32)">
            <summary>
            Removes a child from this node
            </summary>
            <param name="i"></param>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.ParseException">
            <summary>
            This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            </summary>
            <remarks>
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.#ctor(NCDK.Smiles.SMARTS.Parser.Token,System.Int32[][],System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            This constructor is used by the method "generateParseException"
            in the generated parser.  Calling this constructor generates
            a new object of this type with the fields "currentToken",
            "expectedTokenSequences", and "tokenImage" set.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ParseException.CurrentToken">
            <summary>
            This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            following this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ParseException.ExpectedTokenSequences">
            <summary>
            Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.ParseException.TokenImage">
            <summary>
            This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.Initialise(NCDK.Smiles.SMARTS.Parser.Token,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{System.Int32}},System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            It uses "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser) the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.ParseException.AddEscapes(System.String)">
            <summary>
            Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SimpleCharStream">
            <summary>
            An implementation of interface CharStream, where the stream is assumed to
            contain only ASCII characters (without unicode processing).
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.staticFlag">
            <summary>Whether parser is static.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.bufpos">
            <summary>Position in buffer.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.BeginToken">
            <summary>Start.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReadChar">
            <summary>Read a character.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetEndColumn">
            <summary>Get token end column number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetEndLine">
            <summary>Get token end line number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetBeginColumn">
            <summary>Get token beginning column number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetBeginLine">
            <summary>Get token beginning line number.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.Backup(System.Int32)">
            <summary>Backup a number of characters.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.TextReader)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.#ctor(System.IO.Stream)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.String,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.ReInit(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetImage">
            <summary>Get token literal value.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.GetSuffix(System.Int32)">
            <summary>Get the suffix.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.Done">
            <summary>Reset buffer when finished.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleCharStream.AdjustBeginLineColumn(System.Int32,System.Int32)">
            <summary>
            Method to adjust line and column numbers for the start of a token.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleNode.JjtAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SimpleNode.ChildrenAccept(NCDK.Smiles.SMARTS.Parser.ISMARTSParserVisitor,System.Object)">
            <summary>Accept the visitor. </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.Smarts2MQLVisitor">
            <summary>
            An AST tree visitor. It is a prototype that translate Smarts to MQL.
            It is far from fully functioning.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SmartsDumpVisitor">
            <summary>
            An AST Tree visitor. It dumps the whole AST tree into console
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParser">
            <summary>
            This parser implements a nearly complete subset of the SMARTS syntax as defined on
            <see href="http://www.daylight.com/dayhtml/doc/theory/theory.smarts.html">the Daylight website</see>. 
            </summary>
            <example>
            Example code using SMARTS substructure search looks like:
            <code>            SmilesParser sp = new SmilesParser();
             IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
             QueryAtomContainer query = SMARTSParser.Parse("C*C");
             bool queryMatch = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
            </example>
            <remarks>
            This parser is based on JJTree and it generates an AST (Abstract Syntax Tree)
            <para>To get the AST, the code looks like:
            <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart start = parser.Start();
</code>
            </para>
            </remarks>
            <seealso cref="T:NCDK.Isomorphisms.Matchers.SMARTS.SMARTSAtom" />
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Parse(System.String)">
            <summary>
            This method parses a Smarts String and returns an instance of <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer"/>.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.Start">
            <summary>
            <![CDATA[
                                Start ::= <ReactionExpression> <#_WS>
                   ReactionExpression ::= <GroupExpression>? (">" <GroupExpression>? ">" <GroupExpression>?)?
                      GroupExpression ::= ["("] <SmartsExpresion> [")"] ( "." ["("] <SmartsExpression> [")"] )*
                     SmartsExpression ::= <AtomExpression> (
            ( [ <LowAndBond> ] ( <Digit> | <AtomExpression> ) ) |
            ( "(" [ <LowAndBond> ] <SmartsExpression> ")" ) )*
            AtomExpression ::= ( "[" [ <AtomicMass> ] <LowAndExpression> [:<Digit>+] "]" ) | <ExplicitAtomExpression>
                           LowAndBond ::= <OrBond> [ ";" <AndBond> ]
                               OrBond ::= <ExplicitHighAndBond> [ "," <OrBond> ]
                  ExplicitHighAndBond ::= <ImplicitHighAndBond> [ "&" <ExplicitHighAndBond> ]
                  ImplicitHighAndBond ::= <NotBond> [ <ImplicitHighAndBond> ]
                              NotBond ::= [ "!" ] <SimpleBond>
                           SimpleBond ::= "/" | "\\" | "/?" | "\\?" | "=" | "#" | "~" | "@"
               ExplicitAtomExpression ::= [ "B" | "C" | "N" | "O" | "P" | "S" | "F" | "CL" | "BR" | "I"
                                          | "c" | "o" | "n" | "*" | "A" | "a" | "p" | "as" | "se" ]
                     LowAndExpression ::= <OrExpression> ( ";" <LowAndExpression> )?
                         OrExpression ::= <ExplicitHighAndExpression> ( "," <OrExpression> ) ?
            ExplicitHighAndExpression ::= <ImplicitHighAndExpression> ( "&" <ExplicitHighAndExpression> )?
            ImplicitHighAndExpression ::= <NotExpression> ( <ImplicitHighAndExpression> ) ?
                        NotExpression ::= "!" ( <PrimitiveAtomExpression> | <RecursiveSmartsExpression> )
            RecursiveSmartsExpression ::= "$" "(" <SmartsExpression> ")"
              PrimitiveAtomExpression ::= <AtomicMass> | <NonHydrogenElement> | "*" | "A" | "a" | "D" (<Digits>)? | "H" (<Digits>)? | "h" (<Digits>)?
                                          | "R" (<Digit>+)? | "r" (<Digit>+)? | "v" (<Digit>+)? | "#X" | "G" (<DIGIT>+)
                                          | "X" (<Digit>+)? | "x" (<Digit>+)? | "^" (<DIGIT>)
                                          | ("+" | "-") (<Digit>+)? | "#" (<Digit>+) | "@" | "@@" | <Digit>+
                                Digit ::= ( "0" - "9")
                   NonHydrogenElement ::= [ "HE" | "LI" | "BE" | "NE" | "NA" | "MG" | "AL" | "SI" | "AR" | "CA" | "SC" |
                                          "TI" | "CR" | "MN" | "FE" | "CO" | "NI" | "CU" | "ZN" | "GA" | "GE" | "AS" |
                                          "SE" | "BR" | "KR" | "RB" | "SR" | "ZR" | "NB" | "MO" | "TC" | "RU" | "RH" |
                                          "PD" | "AG" | "CD" | "IN" | "SN" | "SB" | "TE" | "XE" | "CS" | "BA" | "LA" |
                                          "HF" | "TA" | "RE" | "OS" | "IR" | "PT" | "AU" | "HG" | "TL" | "PB" | "BI" |
                                          "PO" | "AT" | "RN" | "FR" | "RA" | "AC" | "TH" | "PA" |
                                          "B" | "C" | "N" | "O" | "F" | "P" | "S" | "K" | "V" | "Y" | "I" | "U" |
                                          "c" | "o" | "n" | "p" | "as" | "se" ]
            ]]>
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.token_source">
            <summary>Generated Token Manager.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.token">
            <summary>Current token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParser.jj_nt">
            <summary>Next token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.Stream)">
            <summary>Constructor with InputStream.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.Stream,System.String)">
            <summary>Constructor with InputStream and supplied encoding</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.Stream)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.Stream,System.String)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(System.IO.TextReader)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(System.IO.TextReader)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.#ctor(NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager)">
            <summary>Constructor with generated Token Manager.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.ReInit(NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager)">
            <summary>Reinitialise.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GetNextToken">
            <summary>Get the next Token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GetToken(System.Int32)">
            <summary>Get the specific Token.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParser.GenerateParseException">
            <summary>Generate ParseException.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#Start()
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.EOF">
            <summary>End of File.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.WS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_AND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.H_AND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.OR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NOT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.UP_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DN_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.UP_OR_UNSPECIFIED_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DN_OR_UNSPECIFIED_S_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.D_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.T_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AR_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ANY_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_BOND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.c">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.n">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.o">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.s">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.p">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.as_">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.se">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.B">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.C">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.N">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.O">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.F">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.P">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.S">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.I">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.WILDCARD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.a">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.A">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CARET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Q_MARK">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DIGIT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_BRACKET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.L_PAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_PAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R_BRACKET">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DOLLAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PLUS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.h">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.D">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.R">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.r">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.v">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.X">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.x">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.G">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HX">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.H">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.K">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.V">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ZN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.KR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Y">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ZR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RH">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.IN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.XE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HF">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.W">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.OS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.IR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HG">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TL">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BI">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.RA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TH">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PA">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.U">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.AM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.BK">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CF">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ES">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.FM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.MD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.NP">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.CE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.EU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.GD">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.DY">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.HO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ER">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.YB">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.LU">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.PR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.SC">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.ATOM_EXPRESSION">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.Default">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserConstants.TokenImage">
            <summary>Literal token values.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager">
            <summary>Token Manager.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.debugStream">
            <summary>Debug output.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.SetDebugStream(System.IO.Stream)">
            <summary>Set debug output.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.jjstrLiteralImages">
            <summary>Token literal values.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.lexStateNames">
            <summary>Lexer state names.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.jjnewLexState">
            <summary>Lex State array.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.#ctor(NCDK.Smiles.SMARTS.Parser.SimpleCharStream)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.#ctor(NCDK.Smiles.SMARTS.Parser.SimpleCharStream,System.Int32)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.ReInit(NCDK.Smiles.SMARTS.Parser.SimpleCharStream)">
            <summary>Reinitialise parser.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.ReInit(NCDK.Smiles.SMARTS.Parser.SimpleCharStream,System.Int32)">
            <summary>Reinitialise parser.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.SwitchTo(System.Int32)">
            <summary>Switch to specified lex state.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SMARTSParserTokenManager.GetNextToken">
            <summary>Get the next Token.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor">
            <summary>
            An AST tree visitor. It builds an instance of <see cref="T:NCDK.Isomorphisms.Matchers.QueryAtomContainer" /> 
            from the AST tree.
            </summary>
            <example>
            To use this visitor:
            <code>            SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
            ASTStart ast = parser.Start();
            SmartsQueryVisitor visitor = new SmartsQueryVisitor();
            QueryAtomContainer query = (QueryAtomContainer)visitor.Visit(ast, null);
</code>
            </example>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.neighbors">
            <summary>
            Maintain order of neighboring atoms - required for atom-based
            stereochemistry.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.tetrahedral">
            <summary>
            Lookup of atom indices.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.stereoBonds">
            <summary>
            Stores the directional '/' or '\' bonds. Speeds up looking for double
            bond configurations.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.doubleBonds">
            <summary>
            Stores the double bonds in the query.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor.FindStereoBond(NCDK.IAtom)">
            <summary>
            Locate a stereo bond adjacent to the <paramref name="atom"/>.
            </summary>
            <param name="atom">an atom</param>
            <returns>a stereo bond or null if non found</returns>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.Token">
            <summary>
            Describes the input token stream.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.kind">
            <summary>
            An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.beginLine">
            <summary>The line number of the first character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.beginColumn">
            <summary>The column number of the first character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.endLine">
            <summary>The line number of the last character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.endColumn">
            <summary>The column number of the last character of this Token.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.image">
            <summary>
            The string image of the token.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.next">
            <summary>
            A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.specialToken">
            <summary>
            This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.Token.value">
            <summary>
            An optional attribute value of the Token.
            Tokens which are not used as syntactic sugar will often contain
            meaningful values that will be used later on by the compiler or
            interpreter. This attribute value is often different from the image.
            Any subclass of Token that actually wants to return a non-null value can
            override this method as appropriate.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor">
            <summary>
            No-argument constructor
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor(System.Int32)">
            <summary>
            Constructs a new token for the specified Image.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new token for the specified Image and Kind.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.ToString">
            <summary>
            Returns the image.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.Token.NewToken(System.Int32,System.String)">
             <summary>
             Returns a new Token object, by default. However, if you want, you
             can create and return subclass objects based on the value of ofKind.
             Simply add the cases to the switch for all those special cases.
             For example, if you have a subclass of Token called IDToken that
             you want to create if ofKind is ID, simply add something like :
            
                case MyParserConstants.ID : return new IDToken(ofKind, image);
            
             to the following switch statement. Then you can cast matchedToken
             variable to the appropriate type and use sit in your lexical actions.
             </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.TokenManagerException">
            <summary>Token Manager Error.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes">
            <summary>
            Ordinals for various reasons why an Error of this type can be thrown.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.LexicalError">
            <summary>
            Lexical error occurred.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.StaticLexicalError">
            <summary>
            An attempt was made to create a second instance of a static token manager.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.InvalidLexicalState">
            <summary>
            Tried to change to an invalid lexical state.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.LoopDetected">
            <summary>
            Detected (and bailed out of) an infinite loop in the token manager.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.errorCode">
            <summary>
            Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenManagerException.AddEscapes(System.String)">
            <summary>
            Replaces unprintable characters by their escaped (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenManagerException.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary>
            Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            </summary>
            <remarks>
            Parameters :
            <list type="bullet">
            <item><term></term><description></description></item>
            <item><term></term><description></description></item>
            <item><term>EOFSeen</term><description>indicates if EOF caused the lexical error</description></item>
            <item><term>curLexState</term><description>lexical state in which this error occurred</description></item>
            <item><term>errorLine</term><description>line number when the error occurred</description></item>
            <item><term>errorColumn</term><description>column number when the error occurred</description></item>
            <item><term>errorAfter</term><description>prefix that was seen before this error occurred</description></item>
            <item><term>curchar</term><description>the offending character</description></item>
            </list>
            <note type="note">
            You can customize the lexical error message by modifying this method.
            </note>
            </remarks>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.Parser.TokenManagerException.Message">
            <summary>
            You can also modify the body of this method to customize your error messages.
            </summary>
            <remarks>
            For example, cases like <see cref="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.LoopDetected"/> and <see cref="F:NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes.InvalidLexicalState"/> are not
            of end-users concern, so you can return something like :
            <para>
            <pre>
                "Internal Error : Please file a bug report .... "
            </pre>     
            </para>
            from this method for such cases in the release version of your parser.
            </remarks>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenManagerException.#ctor">
            <summary>No arg constructor.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenManagerException.#ctor(System.String,NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes)">
            <summary>Constructor with message and reason.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.Parser.TokenManagerException.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char,NCDK.Smiles.SMARTS.Parser.TokenManagerException.ErrorCodes)">
            <summary>Full Constructor.</summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter">
            <summary>
            A filter for substructure matches implementing the logic for Atom-Atom Mapping matching. The following
            table from the Daylight theory manual summarises the expected functionality:
            </summary>
            <pre>
            C>>C                 CC>>CC    4 hits                        No maps, normal match.
            C>>C                 [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   No maps in query, maps in target are ignored.
            [C:1]>>C             [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   Unpaired map in query ignored.
            [C:1]>>[C:1]         CC>>CC  0 hits                          No maps in target, hence no matches.
            [C:?1]>>[C:?1]       CC>>CC  4 hits                          Query says mapped as shown or not present.
            [C:1]>>[C:1]         [CH3:7][CH3:8]>>[CH3:7][CH3:8] 2 hits   Matches for target 7,7 and 8,8 atom pairs.
            [C:1]>>[C:2]         [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   When a query class is not found on both sides of the
                                                                         query, it is ignored; this query does NOT say that the
                                                                         atoms are in different classes.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:7]>>[CH3:7][CH3:7] 4 hits   Atom maps match with "or" logic. All atoms  get bound to
                                                                         class 7.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:8]>>[CH3:7][CH3:8] 4 hits   The reactant atoms are bound to classes 7 and 8. Note that
                                                                         having the first query atom bound to class 7 does not
                                                                         preclude binding the second atom. Next, the product
                                                                         atom can bind to classes 7 or 8.
            [C:1][C:1]>>[C:1]    [CH3:7][CH3:7]>>[CH3:7][CH3:8] 2 hits   The reactants are bound to class 7. The product atom can
                                                                         bind to class 7 only.
            </pre>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Mapidx(NCDK.IAtom)">
            <summary>
            Safely access the mapidx of an atom, returns 0 if null.
            </summary>
            <param name="atom">atom</param>
            <returns>mapidx, 0 if undefined</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Role(NCDK.IAtom)">
            <summary>
            Safely access the reaction role of an atom, returns <see cref="F:NCDK.ReactionRole.None"/> if null.
            </summary>
            <param name="atom">atom</param>
            <returns>mapidx, None if undefined</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.Apply(System.Int32[])">
            <summary>
            Filters a structure match (described as an index permutation query -> target) for
            those where the atom-atom maps are acceptable.
            </summary>
            <param name="perm">permuation</param>
            <returns>whether the match should be accepted</returns>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsAtomAtomMapFilter.MappedPairs">
            <summary>
            Helper class list all reactant atom indices (rIdxs) and product
            atom indices (pIdxs) that are in the same Atom-Atom-Mapping class.
            </summary>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SmartsPattern">
            <summary>
            A <see cref="T:NCDK.Isomorphisms.Pattern" /> for matching a single SMARTS query against multiple target
            compounds. The class should <b>not</b> be used for matching many queries
            against a single target as in substructure keyed fingerprints. The <see cref="T:NCDK.Smiles.SMARTS.SMARTSQueryTool" /> 
            is currently a better option as less target initialistion is performed.
            </summary>
            <example>
            Simple usage:
            <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");

                foreach (var ac in acs)
                {
                    if (ptrn.Matches(ac))
                    {
                        // 'ac' contains the pattern
                    }
                }
</code>
            Obtaining a <see cref="T:NCDK.Isomorphisms.Mappings" /> instance and determine the number of unique
            matches.
            <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");

                foreach (var ac in acs)
                {
                    nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                }
</code>
            </example>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.query">
            <summary>Parsed query.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.pattern">
            <summary>Subgraph mapping.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.doPrep">
            <summary>
            Prepare the target molecule (i.e. detect rings, aromaticity) before
            matching the SMARTS.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SmartsPattern.arom">
            <summary>Aromaticity model.</summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.#ctor(System.String)">
            <summary>
            Internal constructor.
            </summary>
            <param name="smarts">pattern</param>
            <exception cref="T:System.IO.IOException">the pattern could not be parsed</exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.SetPrepare(System.Boolean)">
            <summary>
            Sets whether the molecule should be "prepared" for a SMARTS match,
            including set ring flags and perceiving aromaticity. The main reason
            to skip preparation (via {@link #Prepare(IAtomContainer)}) is if it has
            already been done, for example when matching multiple SMARTS patterns.
            </summary>
            <param name="doPrep">whether preparation should be done</param>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.Match(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.MatchAll(NCDK.IAtomContainer)">
            <summary>
            Obtain the mappings of the query pattern against the target compound. Any
            initialisations required for the SMARTS match are automatically
            performed. The Daylight aromaticity model is applied clearing existing
            aromaticity. <b>Do not use this for matching multiple SMARTS againsts the
            same container</b>.
            </summary>
            <example>
            <code>                 Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");
                 int nUniqueHits = 0;
                
                 foreach (var ac in acs) {
                   nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                 }
</code>
            See <see cref="T:NCDK.Isomorphisms.Mappings" /> for available methods.
            </example>
            <param name="target">the target compound in which we want to match the pattern</param>
            <returns>mappings of the query to the target compound</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SmartsPattern.Create(System.String)">
            <summary>
            Create a <see cref="T:NCDK.Isomorphisms.Pattern"/> that will match the given <paramref name="smarts"/> query.
            </summary>
            <param name="smarts">SMARTS pattern string</param>
            <returns>a new pattern</returns>
            <exception cref="T:System.IO.IOException">the smarts could not be parsed</exception> 
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SMARTSQueryTool">
            <summary>
            This class provides a easy to use wrapper around SMARTS matching functionality. 
            </summary>
            <remarks>
            <para>
            User code that wants to do
            SMARTS matching should use this rather than using SMARTSParser (and <see cref="T:NCDK.Isomorphisms.UniversalIsomorphismTester" />) directly.
            </para>
            <list type="bullet">
            <listheader><description>Unsupported Features</description></listheader>
            <item><description>Component level grouping</description></item>
            <item><description>Stereochemistry</description></item>
            <item><description>Reaction support</description></item>
            </list>
            <h3>SMARTS Extensions</h3>
            <para>
            Currently the CDK supports the following SMARTS symbols, that are not described in the Daylight specification.
            However they are supported by other packages and are noted as such.
            </para>
            <list type="table">
            <listheader>
            <term>Symbol</term>
            <term>Meaning</term>
            <term>Default</term>
            <term>Notes</term>
            </listheader>
            <item>
            <term>Gx</term>
            <term>Periodic group number</term>
            <term>None</term>
            <term>x must be specified and must be a number between 1 and 18. This symbol is supported by the MOE SMARTS implementation</term>
            </item>
            <item>
            <term>#X</term>
            <term>Any non-carbon heavy element</term>
            <term>None</term>
            <term>This symbol is supported by the MOE SMARTS implementation</term>
            </item>
            <item>
            <term>^x</term>
            <term>Any atom with the a specified hybridization state</term>
            <term>None</term>
            <term>x must be specified and should be between 1 and 8 (inclusive), corresponding to SP1, SP2, SP3, SP3D1, SP3D2 SP3D3, SP3D4 and SP3D5. Supported by the OpenEye SMARTS implementation</term>
            </item>
            </list>
            <note type="note">
            <list type="bullet">
            <item>
            <term>
            As <see href="http://sourceforge.net/mailarchive/message.php?msg_name=4964F605.1070502%40emolecules.com">described</see>
            by Craig James the "h&lt;n&gt;" SMARTS pattern should not be used. It was included in the Daylight spec
            for backwards compatibility. To match hydrogens, use the "H&lt;n&gt;" pattern.
            </term>
            <term>
            The wild card pattern ("*") will not match hydrogens (explicit or implicit) unless an isotope is specified. In other
            words, "*" gives two hits against "C[2H]" but 1 hit against "C[H]". This also means
            that it gives no hits against "[H][H]". This is contrary to what is shown by Daylights 
            <see href="http://www.daylight.com/daycgi_tutorials/depictmatch.cgi">depictmatch</see> service, but is based on this 
            <see href="https://sourceforge.net/mailarchive/message.php?msg_name=4964FF9D.3040004%40emolecules.com">discussion</see>. A
            work around to get "*" to match "[H][H]" is to write it in the form "[1H][1H]".
            <para>
            It's not entirely clear what the behavior of * should be with respect to hydrogens. it is possible that the code will
            be updated so that "*" will not match <i>any</i> hydrogen in the future.</para>
            </term>
            <term>
            The CDKHueckelAromaticityDetector only considers single rings and two fused non-spiro
            rings. As a result, it does not properly detect aromaticity in polycyclic systems such as
            "[O-]C(=O)c1ccccc1c2c3ccc([O-])cc3oc4cc(=O)ccc24". Thus SMARTS patterns that depend on proper aromaticity
            detection may not work correctly in such polycyclic systems
            </term>
            </item>
            </list>
            </note>
            </remarks>
            <example>
            <code>                SmilesParser sp = new SmilesParser();
                IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
                SMARTSQueryTool querytool = new SMARTSQueryTool("O=CO");
                bool status = querytool.Matches(atomContainer);
                if (status)
                {
                    int nmatch = querytool.MatchesCount;
                    var mappings = querytool.GetMatchingAtoms();
                    foreach (var atomIndices in mappings)
                    {
                        // do something
                    }
                }
</code>
            </example>
        </member>
        <member name="T:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet">
            <summary>
            Defines which set of rings to define rings in the target.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.SmallestSetOfSmallestRings">
            <summary>
            Smallest Set of Smallest Rings (or Minimum Cycle Basis - but not
            strictly the same). Defines what is typically thought of as a 'ring'
            however the non-uniqueness leads to ambiguous matching.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.EssentialRings">
            <summary>
            Intersect of all Minimum Cycle Bases (or SSSR) and thus is a subset.
            The set is unique but may excludes rings (e.g. from bridged systems).
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.RelevantRings">
            <summary>
            Union of all Minimum Cycle Bases (or SSSR) and thus is a superset.
            The set is unique but may include more rings then is necessary.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.RingSet.ComputeRingSet(NCDK.IAtomContainer)">
            <summary>
            Compute a ring set for a molecule.
            </summary>
            <param name="m">molecule</param>
            <returns>the ring set for the molecule</returns>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.ringSet">
            <summary>Which short cyclic set should be used.</summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.aromaticity">
            <summary>
            Aromaticity perception - dealing with SMARTS we should use the Daylight
            model. This can be set to a different model using <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetAromaticity(NCDK.Aromaticities.Aromaticity)"/>.
            </summary>
        </member>
        <member name="F:NCDK.Smiles.SMARTS.SMARTSQueryTool.skipAromaticity">
            <summary>
            Logical flag indicates whether the aromaticity model should be skipped.
            Generally this should be left as false to ensure the structures being
            matched are all treated the same. The flag can however be turned off if
            the molecules being tests are known to all have the same aromaticity
            model.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.#ctor(System.String)">
            <summary>
            Create a new SMARTS query tool for the specified SMARTS string. Query
            objects will contain a reference to the specified <see cref="T:NCDK.IChemObjectBuilder"/>.
            </summary>
            <param name="smarts">SMARTS query string</param>
            <exception cref="T:System.ArgumentException">if the SMARTS string can not be handled</exception>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetQueryCacheSize(System.Int32)">
            <summary>
            Set the maximum size of the query cache.
            </summary>
            <param name="maxEntries">The maximum number of entries</param>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings">
            <summary>
            Indicates that ring properties should use the Smallest Set of Smallest
            Rings. The set is not unique and may lead to ambiguous matches.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseRelevantRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseRelevantRings">
            <summary>
            Indicates that ring properties should use the Relevant Rings. The set is
            unique and includes all of the SSSR but may be exponential in size.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings">
            <summary>
            Indicates that ring properties should use the Essential Rings (default).
            The set is unique but only includes a subset of the SSSR.
            </summary>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseSmallestSetOfSmallestRings"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.UseEssentialRings"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.SetAromaticity(NCDK.Aromaticities.Aromaticity)">
            <summary>
            Set the aromaticity perception to use. Different aromaticity models
            may required certain attributes to be set (e.g. atom typing). These
            will not be automatically configured and should be preset before matching.
            </summary>
            <example>
            <code>                SMARTSQueryTool sqt = new SMARTSQueryTool(someSmartsPattern);
                sqt.SetAromaticity(new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder));
                foreach (var molecule in molecules)
                {
                    // CDK Aromatic model needs atom types
                    AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                    sqt.Matches(molecule);
                }
</code>
            </example>
            <param name="aromaticity">the new aromaticity perception</param>
            <seealso cref="T:NCDK.Aromaticities.ElectronDonation" />
            <seealso cref="T:NCDK.Graphs.Cycles" />
        </member>
        <member name="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.Smarts">
            <summary>
            The current SMARTS pattern being used.
            </summary>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)">
            <summary>
            Perform a SMARTS match and check whether the query is present in the target molecule. 
            <para>
            This function simply
            checks whether the query pattern matches the specified molecule. However the function will also, internally, save
            the mapping of query atoms to the target molecule</para>
            </summary>
            <remarks>
            <note type="note">
            This method performs a simple caching scheme, by comparing the current molecule to the previous
            molecule by reference. If you repeatedly match different SMARTS on the same molecule, this method will avoid
            initializing ( ring perception, aromaticity etc.) the molecule each time. If however, you modify the molecule
            between such multiple matchings you should use the other form of this method to force initialization.
            </note>
            </remarks>
            <param name="atomContainer">The target molecule</param>
            <returns>true if the pattern is found in the target molecule, false otherwise</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in ring, aromaticity or isomorphism perception</exception>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms"/>
            <seealso cref="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount"/>
            <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer,System.Boolean)"/>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Perform a SMARTS match and check whether the query is present in the target molecule. 
            <para>This function simply
            checks whether the query pattern matches the specified molecule. However the function will also, internally, save
            the mapping of query atoms to the target molecule</para>
            </summary>
            <param name="atomContainer">The target moleculoe</param>
            <param name="forceInitialization">If true, then the molecule is initialized (ring perception, aromaticity etc). If
                                       false, the molecule is only initialized if it is different (in terms of object
                                       reference) than one supplied in a previous call to this method.</param>
            <returns>true if the pattern is found in the target molecule, false otherwise</returns>
            <exception cref="T:NCDK.CDKException">if there is an error in ring, aromaticity or isomorphism perception</exception>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms"/>
            <seealso cref="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount"/>
            <seealso cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)"/>
        </member>
        <member name="P:NCDK.Smiles.SMARTS.SMARTSQueryTool.MatchesCount">
            <summary>
            Returns the number of times the pattern was found in the target molecule. 
            <para>This function should be called
            after <see cref="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.Matches(NCDK.IAtomContainer)"/>. If not, the results may be undefined.</para>
            </summary>
            <returns>The number of times the pattern was found in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetMatchingAtoms">
            <summary>
            Get the atoms in the target molecule that match the query pattern. 
            <para>Since there may be multiple matches, the
            return value is a List of List objects. Each List object contains the indices of the atoms in the target
            molecule, that match the query pattern</para>
            </summary>
            <returns>A List of List of atom indices in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.GetUniqueMatchingAtoms">
            <summary>
            Get the atoms in the target molecule that match the query pattern. 
            <para>
            Since there may be multiple matches, the
            return value is a List of List objects. Each List object contains the unique set of indices of the atoms in the
            target molecule, that match the query pattern
            </para>
            </summary>
            <returns>A List of List of atom indices in the target molecule</returns>
        </member>
        <member name="M:NCDK.Smiles.SMARTS.SMARTSQueryTool.InitializeMolecule">
            <summary>
            Prepare the target molecule for analysis. 
            <para>
            We perform ring perception and aromaticity detection and set up
            the appropriate properties. Right now, this function is called each time we need to do a query and this is
            inefficient.</para>
            </summary>
            <exception cref="T:NCDK.CDKException">if there is a problem in ring perception or aromaticity detection, which is usually related to a timeout in the ring finding code.</exception>
        </member>
        <member name="T:NCDK.SMSD.AbstractMCS">
            <summary>
            Interface for all MCS algorithms.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.Init(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean,System.Boolean)">
            <summary>
            initialize query and target molecules.
            </summary>
            <param name="source">query mol</param>
            <param name="target">target mol</param>
            <param name="removeHydrogen">true if remove H (implicit) before mapping</param>
            <param name="cleanAndConfigureMolecule">eg: percieveAtomTypesAndConfigureAtoms, detect aromaticity etc</param>
             <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.Init(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <summary>
            initialize query and target molecules.
            </summary>
            <remarks>
            Note: Here its assumed that hydrogens are implicit
            and user has called these two methods
            percieveAtomTypesAndConfigureAtoms and CDKAromicityDetector
            before initializing calling this method.
            </remarks>
            <param name="source">query mol</param>
            <param name="target">target mol</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.SetChemFilters(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            initialize query and target molecules.
            </summary>
            <param name="stereoFilter">set true to rank the solutions as per stereo matches</param>
            <param name="fragmentFilter">set true to return matches with minimum fragments</param>
            <param name="energyFilter">set true to return matches with minimum bond changes based on the bond breaking energy</param>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetEnergyScore(System.Int32)">
            <summary>
            Returns summation energy score of the disorder if the MCS is removed
            from the target and query graph. Amongst the solutions, a solution
            with lowest energy score is preferred.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>Total bond breaking energy required to remove the mapped part</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFragmentSize(System.Int32)">
            <summary>
            Returns number of fragment generated in the solution space,
            if the MCS is removed from the target and query graph.
            Amongst the solutions, a solution with lowest fragment size
            is preferred.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>Fragment Count(s) generated after removing the mapped parts</returns>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.ProductMolecule">
            <summary>
            Modified target molecule on which mapping was performed.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.ReactantMolecule">
            <summary>
            Modified query molecule on which mapping was performed.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetStereoScore(System.Int32)">
            <summary>
            Returns a number which denotes the quality of the mcs.
            A solution with highest stereo score is preferred over other
            scores.
            </summary>
            <param name="key">Index of the mapping solution</param>
            <returns>true if no stereo mismatch occurs
            else false if stereo mismatch occurs</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.IsStereoMisMatch">
            <summary>
            Returns true if mols have different stereo
            chemistry else false if no stereo mismatch.
            </summary>
            <returns>true if mols have different stereo</returns>
            chemistry else false if no stereo mismatch.
            true if stereo mismatch occurs
            else true if stereo mismatch occurs.
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.IsSubgraph">
            <summary>
            Checks if query is a subgraph of the target.
            Returns true if query is a subgraph of target else false
            </summary>
            <returns>true if query molecule is a subgraph of the target molecule</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetTanimotoSimilarity">
            <summary>
            Returns Tanimoto similarity between query and target molecules
            (Score is between 0-min and 1-max).
            </summary>
            <returns>Tanimoto Similarity between 0 and 1</returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetEuclideanDistance">
            <summary>
            Returns Euclidean Distance between query and target molecule.
            <returns>Euclidean Distance (lower the score, better the match)</returns>
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetAllAtomMapping">
            <summary>
            Returns all plausible mappings between query and target molecules
            Each map in the list has atom-atom equivalence of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule.
            </summary>
            <returns>All possible MCS atom Mappings</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetAllMapping">
            <summary>
            Returns all plausible mappings between query and target molecules
            Each map in the list has atom-atom equivalence index of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule.
            </summary>
            <returns>All possible MCS Mapping Index</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFirstAtomMapping">
            <summary>
            Returns one of the best matches with atoms mapped.
            </summary>
            <returns>Best Atom Mapping</returns>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCS.GetFirstMapping">
            <summary>
            Returns one of the best matches with atom indexes mapped.
            </summary>
            <returns>Best Mapping Index</returns>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.BondSensitiveTimeOut">
            <summary>
            timeout in mins (default 0.10 min) for bond sensitive searches
            </summary>
        </member>
        <member name="P:NCDK.SMSD.AbstractMCS.BondInSensitiveTimeOut">
            <summary>
            timeout in mins (default 1.00 min) for bond insensitive searches
            </summary>
        </member>
        <member name="T:NCDK.SMSD.AbstractMCSAlgorithm">
            <summary>
            Interface for MCS search algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractMCSAlgorithm.SearchMCS(System.Boolean)">
            <summary>
            Initialise the MCS search algorithm. Each MCS algorithm should contain
            this method.
            </summary>
            <param name="shouldMatchBonds">bond match</param>
        </member>
        <member name="T:NCDK.SMSD.AbstractSubGraph">
            <summary>
            Interface class for reporting only substructure searches.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AbstractSubGraph.IsSubgraph(System.Boolean)">
            <summary>
            Initialise the Subgraph search algorithm. Each Subgraph algorithm
            should contain this method.
            </summary>
            <returns>true if Query/reactant is a subgraph of Target/product else false</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithm">
            <summary>
            This class represents various algorithm type supported by SMSD.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.Default">
            <summary>
            Default SMSD algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.MCSPlus">
            <summary>
            MCS Plus algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.VFLibMCS">
            <summary>
            VF Lib based MCS algorithm.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.CDKMCS">
            <summary>
            CDK UIT MCS.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.SubStructure">
            <summary>
            Substructure search will return all maps.
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Algorithm.TurboSubStructure">
            <summary>
            Substructure search will return first map.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.AlgorithmTools.Description(NCDK.SMSD.Algorithm)">
            <summary>
            short description of the algorithm.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher">
            <summary>
            Checks if a bond is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor(NCDK.IAtomContainer,NCDK.IBond,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="queryMol">query Molecule</param>
            <param name="queryBond">query Molecule</param>
            <param name="shouldMatchBonds">bond match flag</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryBond)">
            <summary>
            Constructor
            </summary>
            <param name="queryBond">query Molecule</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.Matches(NCDK.IAtomContainer,NCDK.IBond)">
            <inheritdoc/>
            <param name="targetContainer">target container</param>
            <param name="targetBond">target bond</param>
            <returns>true if bonds match</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultBondMatcher.IsBondTypeMatch(NCDK.IBond)">
            <summary>
            Return true if a bond is matched between query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Constructor
            </summary>
            <param name="smartQueryAtom">query atom</param>
            <param name="container"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.SetMaximumNeighbors(System.Int32)">
             <summary>
            
             <param name="maximum">numbers of connected atoms allowed</param>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultMCSPlusAtomMatcher.Matches(NCDK.IAtomContainer,NCDK.IAtom)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.IsBondMatchFlag">
            <summary>
            <returns>the shouldMatchBonds</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultRGraphAtomMatcher.SetMaximumNeighbors(System.Int32)">
            <summary>
            
            </summary>
            <param name="maximum">numbers of connected atoms allowed</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher">
            <summary>
            Checks if atom is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="atom">query atom</param>
            <param name="shouldMatchBonds">bond matching flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtom,NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Constructor
            </summary>
            <param name="smartQueryAtom">query atom</param>
            <param name="container"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.#ctor(NCDK.IAtomContainer,NCDK.IAtom,System.Int32,System.Boolean)">
            <summary>
            Constructor
            <param name="queryContainer">query atom container</param>
            <param name="template">query atom</param>
            <param name="blockedPositions">/// <param name="shouldMatchBonds">bond matching flag</param></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFAtomMatcher.SetMaximumNeighbors(System.Int32)">
             <summary>
            
             <param name="maximum">numbers of connected atoms allowed</param>
             </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher">
            <summary>
            Checks if a bond is matching between query and target molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor">
            <summary>
            Bond type flag
            Constructor
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor(NCDK.IAtomContainer,NCDK.IBond,System.Boolean)">
            <summary>
            Constructor
            <param name="queryMol">query Molecule</param>
            <param name="queryBond">query Molecule</param>
            <param name="shouldMatchBonds">bond match flag</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.#ctor(NCDK.Isomorphisms.Matchers.IQueryBond)">
            <summary>
            Constructor
            <param name="queryBond">query Molecule</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.Matches(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties,NCDK.IBond)">
            <inheritdoc/>
            <param name="targetConatiner">target container</param>
            <param name="targetBond">target bond</param>
            <returns>true if bonds match</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Matchers.DefaultVFBondMatcher.IsBondTypeMatch(NCDK.IBond)">
            <summary>
            Return true if a bond is matched between query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.IAtomMatcher">
            <summary>
            Interface for the AtomMatcher (atoms) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.IBondMatcher">
            <summary>
            Interface for the BondMatcher (bonds) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.IVFAtomMatcher">
            <summary>
            Interface for the AtomMatcher (atoms) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Matchers.IVFBondMatcher">
            <summary>
            Interface for the BondMatcher (bonds) in graph.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McGregor">
            <summary>
            Class which reports MCS solutions based on the McGregor algorithm
            published in 1982.
            </summary>
            <remarks>
             <para>The SMSD algorithm is described in this paper.
            please refer Rahman <i>et.al. 2009</i>
             <token>cdk-cite-SMSD2009</token>.
             </para></remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IEnumerable{System.Collections.Generic.IReadOnlyList{System.Int32}})">
            <summary>
            Constructor for the McGregor algorithm.
            <param name="source"></param>
            <param name="target"></param>
            <param name="mappings"></param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.StartMcGregorIteration(System.Int32,System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Int32})">
            <summary>
            Start McGregor search and extend the mappings if possible.
            </summary>
            <param name="largestMappingSize"></param>
            <param name="presentMapping"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregor.StartMcGregorIteration(System.Int32,System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Start McGregor search and extend the mappings if possible.
            </summary>
            <param name="largestMappingSize"></param>
            <param name="cliqueVector"></param>
            <param name="compGraphNodes"></param>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.Mappings">
            <summary>
            Returns computed mappings.
            <returns>mappings</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.MCSSize">
            <summary>
            Returns MCS size.
            <returns>MCS size</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.IsNewMatrix">
            <summary>
            Checks if its a new Matrix.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McGregor.IsBondMatch">
            <summary>
            Should bonds match
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McGregorChecks">
            <summary>
            Class to perform check/methods for McGregor class.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McGregorChecks.RemoveRedundantArcs(System.Int32,System.Int32,System.Collections.Generic.IList{System.Int32},NCDK.SMSD.Algorithms.McGregors.McgregorHelper)">
            <summary>
            The function is called in function partsearch. The function is given a temporary matrix and a position (row/column)
            within this matrix. First the function sets all entries to zero, which can be exlcuded in respect to the current
            atom by atom matching. After this the function replaces all entries in the same row and column of the current
            position by zeros. Only the entry of the current position is set to one.
            Return value "count_arcsleft" counts the number of arcs, which are still in the matrix.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.McgregorHelper">
            <summary>
            Helper Class for McGregor algorithm.
            </summary>
            <remarks>
            The second part of the program extents the mapping by the McGregor algorithm in case,
            that not all atoms of molecule A and molecule B are mapped by the clique approach.
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.#ctor(System.Boolean,System.Int32,System.Collections.Generic.IList{System.Int32},System.Int32,System.Int32,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String},System.Int32,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Stores the variables
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondSetA">
            <summary>
            <returns>the cBondSetA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondSetB">
            <summary>
            <returns>the cBondSetB</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.IsMappingCheckFlag">
            <summary>
            <returns>the mappingCheckFlag</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.MappedAtomCount">
            <summary>
            <returns>the mappedAtomCount</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetMappedAtomsOrg">
            <summary>
            <returns>the mappedAtomsOrg</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.NeighborBondNumA">
            <summary>
            <returns>the neighborBondNumA</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.NeighborBondNumB">
            <summary>
            <returns>the neighborBondNumB</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondNeighborAtomsA">
            <summary>
            <returns>the iBondNeighborAtomsA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondNeighborAtomsB">
            <summary>
            <returns>the iBondNeighborAtomsB</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondNeighborsA">
            <summary>
            <returns>the cBondNeighborsA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetCBondNeighborsB">
            <summary>
            <returns>the cBondNeighborsB</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.SetNumA">
            <summary>
            <returns>the setNumA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondSetA">
            <summary>
            <returns>the iBondSetA</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.McgregorHelper.GetIBondSetB">
            <summary>
            <returns>the iBondSetB</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.QueryProcessor">
            <summary>
            Class to handle mappings of query molecule.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.#ctor(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.String[],System.Int32,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String},System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String})">
            <summary>
            Query molecule
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.CTab1">
             <summary>
            
             <returns>cTabQuery copy</returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.CTab2">
             <summary>
            
             <returns>cTabTarget Copy</returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.NeighborBondNumA">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which are neighbors of the MCS
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.QueryProcessor.BondNumA">
            <summary>
            number of remaining molecule A bonds after the clique search, 
            which aren't neighbors
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.McGregors.TargetProcessor">
            <summary>
            Class to handle mappings of target molecule based on the query.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.TargetProcessor.NeighborBondNumB">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which are neighbors of the MCS
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.McGregors.TargetProcessor.BondNumB">
            <summary>
            number of remaining molecule A bonds after the clique search,
            which aren't neighbors
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF">
            <summary>
            This class implements Bron-Kerbosch clique detection algorithm as it is
            described in [F. Cazals, vertexOfCurrentClique. Karande: An Algorithm for reporting maximal c-cliques;
            processedVertex.Comp. Sc. (2005); vol 349; pp. 484-490]
            
            BronKerboschCazalsKarandeKochCliqueFinder.java
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF.#ctor(System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            Creates index new instance of Bron Kerbosch Cazals Karande Koch Clique Finder
            This class implements Bron-Kerbosch clique detection algorithm as it is
            described in [F. Cazals, vertexOfCurrentClique. Karande: An Algorithm for reporting maximal c-cliques;
            processedVertex.Comp. Sc. (2005); vol 349; pp.
            484-490]
            </summary>
            <param name="compGraphNodesOrg"></param>
            <param name="cEdgesOrg">C-Edges set of allowed edges</param>
            <param name="dEdgesOrg">D-Edges set of prohibited edges</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.BKKCKCF.Init">
            <summary>
            Call the wrapper for ENUMERATE_CLIQUES
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping">
            <summary>
            This class handles MCS between two identical molecules.
            Hence they generate am MCS where all atoms are mapped.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping.ExtractCliqueMapping(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Extract atom mapping from the cliques and stores it in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.ExactMapping.ExtractMapping(System.Collections.Generic.List{System.Collections.Generic.IReadOnlyList{System.Int32}},System.Collections.Generic.IReadOnlyList{System.Int32},System.Collections.Generic.IReadOnlyList{System.Int32})">
            <summary>
            extract atom mapping from the clique List and print it on the screen
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph">
            <summary>
            This class generates compatibility graph between query and target molecule.
            It also markes edges in the compatibility graph as c-edges or d-edges.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.#ctor">
            <summary>
            Default constructor added
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.#ctor(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Generates a compatibility graph between two molecules
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphNodes">
            <summary>
            Generate Compatibility Graph Nodes
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraph">
            <summary>
            Generate Compatibility Graph Nodes Bond Insensitive
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphNodesIfCEdgeIsZero">
            <summary>
            compGraphNodesCZero is used to build up of the edges of the compatibility graph
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.CompatibilityGraphCEdgeZero">
            <summary>
            compatibilityGraphCEdgeZero is used to
            build up of the edges of the
            compatibility graph BIS
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.MCSPluses.GenerateCompatibilityGraph.IsMatchBond">
            <summary>
             the shouldMatchBonds
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus">
            <summary>
            This class handles MCS plus algorithm which is a combination of
            c-clique algorithm and McGregor algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.GetTimeOut">
            <summary>
            the timeout
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.GetTimeManager">
            <summary>
            the timeManager
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the timeManager to set</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler">
            <summary>
            This class acts as a handler class for MCSPlus algorithm.
            </summary>
            <seealso cref="T:NCDK.SMSD.Algorithms.MCSPluses.MCSPlus"/>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler.#ctor">
            <summary>
            Constructor for the MCS Plus algorithm class
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.MCSPluses.MCSPlusHandler.SearchMCS(System.Boolean)">
            <summary>
            Function is called by the main program and serves as a starting point for the comparison procedure.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKMCS">
             <summary>
             This class implements atom multipurpose structure comparison tool.
             It allows to find maximal common substructure, find the
             mapping of atom substructure in another structure, and the mapping of
             two isomorphic structures.
             </summary>
             <remarks>
             <para>Structure comparison may be associated to bondA1 constraints
             (mandatory bonds, e.graphContainer. scaffolds, reaction cores,...) on each source graph.
             The constraint flexibility allows atom number of interesting queries.
             The substructure analysis relies on the CDKRGraph generic class (see: CDKRGraph)
             This class implements the link between the CDKRGraph model and the
             the CDK model in this way the CDKRGraph remains independant and may be used
             in other contexts.</para>
            
             <para>This algorithm derives from the algorithm described in
             <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.</para>
            
             <para>With the <see cref="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)" /> method, the second, and only the second
             argument <b>may</b> be atom <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />, which allows one to do MQL like queries.
             The first IAtomContainer must never be an <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer" />.
             <!-- 次のインクルード タグで一致する要素が見つかりませんでした。--><include file="IncludeExamples.xml" path="Comments/Codes[@id=&quot;NCDK.SMSD.Algorithms.RGraph.CDKMCS_Example.cs&quot;]/*" />
             </para>
             <note type="warning">
                As atom result of the adjacency perception used in this algorithm
                there is atom single limitation : cyclopropane and isobutane are seen as isomorph
                This is due to the fact that these two compounds are the only ones where
                each bondA1 is connected two each other bondA1 (bonds are fully conected)
                with the same number of bonds and still they have different structures
                The algotihm could be easily enhanced with atom simple atom mapping manager
                to provide an atom level overlap definition that would reveal this case.
                We decided not to penalize the whole procedure because of one single
                exception query. Furthermore isomorphism may be discarded since the number of atoms are
                not the same (3 != 4) and in most case this will be already
                screened out by atom fingerprint based filtering.
                It is possible to add atom special treatment for this special query.
                Be reminded that this algorithm matches bonds only.
             </note>
             </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.IsIsomorph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Tests if sourceGraph and targetGraph are isomorph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>true if the 2 molecule are isomorph</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetIsomorphMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first isomorph mapping found or null.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first isomorph mapping found projected of sourceGraph. This is atom List of CDKRMap objects containing Ids of matching bonds.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetIsomorphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first isomorph 'atom mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first isomorph atom mapping found projected on sourceGraph.</returns>
            This is atom List of CDKRMap objects containing Ids of matching atoms.
            <exception cref="T:NCDK.CDKException">if the first molecules is not an instance of <see cref="T:NCDK.Isomorphisms.Matchers.IQueryAtomContainer"/></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetIsomorphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the isomorph 'mappings' found between two
            atom containers.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the 'mappings'</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetSubgraphMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the subgraph 'bondA1 mappings' found for targetGraph in sourceGraph.
            This is an ArrayList of ArrayLists of CDKRMap objects.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the 'mappings' found projected of sourceGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetSubgraphMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first subgraph 'bondA1 mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first subgraph bondA1 mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching bonds.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetSubgraphAtomsMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all subgraph 'atom mappings' found for targetGraph in sourceGraph.
            This is an ArrayList of ArrayLists of CDKRMap objects.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>all subgraph atom mappings found projected on sourceGraph. This is atom
                        List of CDKRMap objects containing Ids of matching atoms.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetSubgraphAtomsMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns the first subgraph 'atom mapping' found for targetGraph in sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the first subgraph atom mapping found projected on sourceGraph.
                       This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.IsSubgraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Tests if targetGraph atom subgraph of sourceGraph.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>true if targetGraph atom subgraph on sourceGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetOverlaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns all the maximal common substructure between 2 atom containers.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="shouldMatchBonds"></param>
            <returns>the list of all the maximal common substructure
                        found projected of sourceGraph (list of <see cref="T:NCDK.IAtomContainer"/>)</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetBitSet(NCDK.IAtomContainer)">
            <summary>
            Transforms an AtomContainer into atom BitArray (which's size = number of bondA1
            in the atomContainer, all the bit are set to true).
            </summary>
            <param name="atomContainer">AtomContainer to transform</param>
            <returns>The bitSet</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.BuildRGraph(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Builds the CDKRGraph ( resolution graph ), from two atomContainer
            (description of the two molecules to compare)
            This is the interface point between the CDK model and
            the generic MCSS algorithm based on the RGRaph.
            </summary>
            <param name="sourceGraph">Description of the first molecule</param>
            <param name="targetGraph">Description of the second molecule</param>
            <param name="shouldMatchBonds"></param>
            <returns>the rGraph</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.Search(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            General Rgraph parsing method (usually not used directly)
            This method is the entry point for the recursive search
            adapted to the atom container input.
            </summary>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <param name="sourceBitSet">initial condition ( bonds from sourceGraph that must be contains in the solution )</param>
            <param name="targetBitSet">initial condition ( bonds from targetGraph that must be contains in the solution )</param>
            <param name="findAllStructure">if false stop at the first structure found</param>
            <param name="findAllMap">if true search all the 'mappings' for one same structure</param>
            <param name="shouldMatchBonds"></param>
            <returns>atom List of Lists of CDKRMap objects that represent the search solutions</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.Project(System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap},NCDK.IAtomContainer,NCDK.SMSD.Algorithms.RGraphs.CDKMCS.IdType)">
            <summary>
            Projects atom list of CDKRMap on atom molecule.
            </summary>
            <param name="rMapList">the list to project</param>
            <param name="graph">the molecule on which project</param>
            <param name="key">the key in the CDKRMap of the molecule graph</param>
            <returns>an AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.ProjectList(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap}},NCDK.IAtomContainer,NCDK.SMSD.Algorithms.RGraphs.CDKMCS.IdType)">
            <summary>
            Projects atom list of RMapsList on atom molecule.
            </summary>
            <param name="rMapsList">list of RMapsList to project</param>
            <param name="graph">the molecule on which project</param>
            <param name="key">the key in the CDKRMap of the molecule graph</param>
            <returns>atom list of AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetMaximum(System.Collections.Generic.IReadOnlyList{NCDK.IAtomContainer},System.Boolean)">
            <summary>
            Removes all redundant solution.
            </summary>
            <param name="graphList">the list of structure to clean</param>
            <returns>the list cleaned</returns>
            <exception cref="T:NCDK.CDKException">if there is atom problem in obtaining subgraphs</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.CheckSingleAtomCases(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks for single atom cases before doing subgraph/isomorphism search
            </summary>
            <param name="sourceGraph">AtomContainer to match on. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">AtomContainer as query. May be an IQueryAtomContainer.</param>
            <returns>List of List of CDKRMap objects for the Atoms (not Bonds!), null if no single atom case</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.MakeAtomsMapsOfBondsMaps(System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap}},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            This makes maps of matching atoms out of atom maps of matching bonds as produced by the Get(Subgraph|Ismorphism)Maps methods.
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">The first atom container. Must not be atom IQueryAtomContainer.</param>
            <param name="targetGraph">The second one (first and second as in getMap). May be an QueryAtomContaienr.</param>
            <returns>A Vector of Vectors of CDKRMap objects of matching Atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.MakeAtomsMapOfBondsMap(System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            This makes atom map of matching atoms out of atom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.NodeConstructor(NCDK.SMSD.Algorithms.RGraphs.CDKRGraph,NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Builds the nodes of the CDKRGraph ( resolution graph ), from
            two atom containers (description of the two molecules to compare)
            </summary>
            <param name="graph">the target CDKRGraph</param>
            <param name="ac1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">second molecule. May be an IQueryAtomContainer.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to identify overlaps</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.ArcConstructor(NCDK.SMSD.Algorithms.RGraphs.CDKRGraph,NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Build edges of the RGraphs
             This method create the edge of the CDKRGraph and
             calculates the incompatibility and neighbourhood
             relationships between CDKRGraph nodes.
            </summary>
            <param name="graph">the rGraph</param>
            <param name="ac1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">second molecule. May be an IQueryAtomContainer.</param>
            <exception cref="T:NCDK.CDKException">if it takes too long to get the overlaps</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.HasCommonAtom(NCDK.IBond,NCDK.IBond)">
            <summary>
            Determines if two bonds have at least one atom in common.
            </summary>
            <param name="bondA">first bondA1</param>
            <param name="bondB">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetCommonSymbol(NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common and returns the common symbol
            </summary>
            <param name="bondA">first bondA1</param>
            <param name="bondB">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.QueryAdjacency(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
            </summary>
            <param name="bondA1">first bondA1</param>
            <param name="bondB1">second bondA1</param>
            <returns>the symbol of the common atom or "" if
                       the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.QueryAdjacencyAndOrder(NCDK.IBond,NCDK.IBond,NCDK.IBond,NCDK.IBond)">
            <summary>
             Determines if 2 bondA1 have 1 atom in common if second is atom query AtomContainer
             and wheter the order of the atoms is correct (atoms match).
            </summary>
            <param name="bond1">first bondA1</param>
            <param name="bond2">second bondA1</param>
            <param name="queryBond1">first query bondA1</param>
            <param name="queryBond2">second query bondA1</param>
            <returns>the symbol of the common atom or "" if the 2 bonds have no common atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.TestSubgraphHeuristics(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             Checks some simple heuristics for whether the subgraph query can
             realistically be atom subgraph of the supergraph. If, for example, the
             number of nitrogen atoms in the query is larger than that of the supergraph
             it cannot be part of it.
            </summary>
            <param name="ac1">the supergraph to be checked. Must not be an IQueryAtomContainer.</param>
            <param name="ac2">the subgraph to be tested for. May be an IQueryAtomContainer.</param>
            <returns>true if the subgraph ac2 has atom chance to be atom subgraph of ac1</returns>
            <exception cref="T:NCDK.CDKException">if the first molecule is an instance of IQueryAtomContainer</exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetTimeOut">
            <returns>the timeout</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.GetTimeManager">
            <returns>the time manager</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCS.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the time manager to set</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKMCSHandler">
            <summary>
            This class acts as a handler class for <see cref="T:NCDK.SMSD.Algorithms.RGraphs.CDKMCS"/> algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCSHandler.#ctor">
            <summary>
            Creates a new instance of MappingHandler
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKMCSHandler.GetUncommon(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            </summary>
            <param name="mol"></param>
            <param name="mcss"></param>
            <param name="shouldMatchBonds"></param>
            <returns>IMolecule Set</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph">
            <summary>
            This class implements the Resolution Graph (CDKRGraph).
            The CDKRGraph is a graph based representation of the search problem.
            An CDKRGraph is constructed from the two compared graphs (G1 and G2).
            Each vertex (node) in the CDKRGraph represents a possible association
            from an edge in G1 with an edge in G2. Thus two compatible bonds
            in two molecular graphs are represented by a vertex in the CDKRGraph.
            Each edge in the CDKRGraph corresponds to a common adjacency relationship
            between the 2 couple of compatible edges associated to the 2 CDKRGraph nodes
            forming this edge.
            </summary>
            <remarks>
            <para>Example:
            <pre>
               G1 : C-C=O  and G2 : C-C-C=0
                    1 2 3           1 2 3 4
            </pre>
            </para>
            <para>The resulting CDKRGraph(G1,G2) will contain 3 nodes:
            <list type="bullet">
               <item>Node sourceBitSet : association between bond C-C :  1-2 in G1 and 1-2 in G2</item>
               <item>Node targetBitSet : association between bond C-C :  1-2 in G1 and 2-3 in G2</item>
               <item>Node C : association between bond C=0 :  2-3 in G1 and 3-4 in G2</item>
             </list>   
             The CDKRGraph will also contain one edge representing the
             adjacency between node targetBitSet and C that is : bonds 1-2 and 2-3 in G1
             and bonds 2-3 and 3-4 in G2.
            </para>
             <para>Once the CDKRGraph has been built from the two compared graphs
             maxIterator becomes a very interesting tool to perform all kinds of
             structural search (isomorphism, substructure search, maximal common
             substructure,....).
            </para>
            <para>The search may be constrained by mandatory elements (e.g. bonds that
             have to be present in the mapped common substructures).
            </para>
            <para>Performing a query on an CDKRGraph requires simply to set the constrains
            (if any) and to invoke the parsing method (Parse())
            </para>
            <para>The CDKRGraph has been designed to be a generic tool. It may be constructed
            from any kind of source graphs, thus maxIterator is not restricted to a chemical
            context.
            </para>
            <para>The CDKRGraph model is indendant from the CDK model and the link between
            both model is performed by the RTools class. In this way the CDKRGraph
            class may be reused in other graph context (conceptual graphs,....)
            </para>
            <note type="important">
            This implementation of the algorithm has not been
            optimized for speed at this stage. It has been
            written with the goal to clearly retrace the
            principle of the underlined search method. There is
            room for optimization in many ways including the
            the algorithm itself.
            </note>
            <para>This algorithm derives from the algorithm described in
            <token>cdk-cite-HAN90</token> and modified in the thesis of T. Hanser <token>cdk-cite-HAN93</token>.</para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.#ctor">
            <summary>
            Constructor for the CDKRGraph object and creates an empty CDKRGraph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.FirstGraphSize">
            <summary>
            the size of the first of the two compared graphs.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.SecondGraphSize">
            <summary>
            the size of the second of the two compared graphs.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.Clear">
            <summary>
            Reinitialisation of the TGraph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.Graph">
            <summary>
            an CDKRGraph is a list of CDKRGraph nodes each node keeping track of its neighbors.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.AddNode(NCDK.SMSD.Algorithms.RGraphs.CDKRNode)">
            <summary>
             Adds a new node to the CDKRGraph.
            <param name="newNode">The node to add to the graph</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.Parse(System.Collections.BitArray,System.Collections.BitArray,System.Boolean,System.Boolean,NCDK.SMSD.Tools.TimeManager)">
            <summary>
             Parsing of the CDKRGraph. This is the main method
             to perform a query. Given the constrains sourceBitSet and targetBitSet
             defining mandatory elements in G1 and G2 and given
             the search options, this method builds an initial set
             of starting nodes (targetBitSet) and parses recursively the
             CDKRGraph to find a list of solution according to
             these parameters.
            </summary>
            <param name="sourceBitSet">constrain on the graph G1</param>
            <param name="targetBitSet">constrain on the graph G2</param>
            <param name="findAllStructure">true if we want all results to be generated</param>
            <param name="findAllMap">true is we want all possible 'mappings'</param>
            <param name="timeManager"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.ParseRec(System.Collections.BitArray,System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Parsing of the CDKRGraph. This is the recursive method
             to perform a query. The method will recursively
             parse the CDKRGraph thru connected nodes and visiting the
             CDKRGraph using allowed adjacency relationship.
            </summary>
            <param name="traversed">node already parsed</param>
            <param name="extension">possible extension node (allowed neighbors)</param>
            <param name="forbidden">node forbidden (set of node incompatible with the current solution)</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.Solution(System.Collections.BitArray)">
             <summary>
             Checks if a potential solution is a real one
             (not included in a previous solution)
              and add this solution to the solution list
             in case of success.
            
             <param name="traversed">new potential solution</param>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.MustContinue(System.Collections.BitArray)">
            <summary>
             Determine if there are potential solution remaining.
            <param name="potentialNode">set of remaining potential nodes</param>
            <returns>true if maxIterator is worse to continue the search</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.BuildB(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
             Builds the initial extension set. This is the
             set of node that may be used as seed for the
             CDKRGraph parsing. This set depends on the constrains
             defined by the user.
            </summary>
            <param name="sourceBitSet">constraint in the graph G1</param>
            <param name="targetBitSet">constraint in the graph G2</param>
            <returns></returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.BitSetToRMap(System.Collections.BitArray)">
             <summary>
              Converts a CDKRGraph bitset (set of CDKRNode)
             to a list of CDKRMap that represents the
             mapping between to substructures in G1 and G2
             (the projection of the CDKRGraph bitset on G1
             and G2).
            
             <param name="set">the BitArray</param>
             <returns>the CDKRMap list</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.SetAllStructure(System.Boolean)">
            <summary>
             Sets the 'AllStructres' option. If true
            all possible solutions will be generated. If false
            the search will stop as soon as a solution is found.
            (e.g. when we just want to know if a G2 is
             a substructure of G1 or not).
            </summary>
            <param name="findAllStructure"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.SetAllMap(System.Boolean)">
            <summary>
             Sets the 'finAllMap' option. If true
            all possible 'mappings' will be generated. If false
            the search will keep only one 'mapping' per structure
            association.
            </summary>
            <param name="findAllMap"></param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.SetMaxIteration(System.Int32)">
            <summary>
            Sets the maxIteration for the CDKRGraph parsing. If set to -1,
            then no iteration maximum is taken into account.
            </summary>
            <param name="maxIterator">The new maxIteration value</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.ToString">
            <summary>
            Returns a string representation of the CDKRGraph.
            </summary>
            <returns>a string representation of the CDKRGraph.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.ProjectG1(System.Collections.BitArray)">
            <summary>
             Projects a CDKRGraph bitset on the source graph G1.
            </summary>
            <param name="set">CDKRGraph BitArray to project</param>
            <returns>The associate BitArray in G1</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.ProjectG2(System.Collections.BitArray)">
            <summary>
             Projects a CDKRGraph bitset on the source graph G2.
            </summary>
            <param name="set">CDKRGraph BitArray to project</param>
            <returns>The associate BitArray in G2</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.IsContainedIn(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
            Test if set sourceBitSet is contained in set targetBitSet.
            </summary>
            <param name="sourceBitSet">a bitSet</param>
            <param name="targetBitSet">a bitSet</param>
            <returns>true if sourceBitSet is contained in targetBitSet</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.IsFindAllStructure">
            <summary>
            flag to define if we want to get all possible 'structures'
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.Solutions">
            <summary>
            The solution list
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.MaxIteration">
            <summary>
            maximal number of iterations before search break
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.IsFindAllMap">
            <summary>
            flag to define if we want to get all possible 'mappings'
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRGraph.IsStop">
            <summary>
            if true is a search has to be stopped
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKRMap">
            <summary>
             An CDKRMap implements the association between an edge (bond) in G1 and an edge
             (bond) in G2, G1 and G2 being the compared graphs in a RGraph context.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMap.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the CDKRMap
            </summary>
            <param name="id1">number of the edge (bond) in the graphe 1</param>
            <param name="id2">number of the edge (bond) in the graphe 2</param>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMap.Id1">
            <summary>
            the id1 attribute of the CDKRMap object
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMap.Id2">
            <summary>
            the id2 attribute of the CDKRMap object
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMap.Equals(System.Object)">
             <summary>
              The equals method.
            
             <param name="obj">The object to compare.</param>
             <returns>true=if both ids equal, else false.</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMap.GetHashCode">
            <summary>
            Returns a hash code for object comparison.
            <returns>Returns a hash code for object comparison.</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler">
            <summary>
            This algorithm derives from the algorithm described in
            [Tonnelier, C. and Jauffret, Ph. and Hanser, Th. and Jauffret, Ph. and Kaufmann, G.,
            Machine Learning of generic reactions:
            3. An efficient algorithm for maximal common substructure determination,
            Tetrahedron Comput. Methodol., 1990, 3:351-358] and modified in the thesis of
            T. Hanser [Unknown BibTeXML type: HAN93].
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.Source">
            <summary>
            Returns source molecule
            </summary>
            <returns>the source</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.Target">
            <summary>
            Returns target molecule
            </summary>
            <returns>the target</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.CalculateOverlapsAndReduce(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates all the possible combinations of MCS
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.CalculateOverlapsAndReduceExactMatch(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.CalculateSubGraphs(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.CalculateIsomorphs(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            This function calculates only one solution (exact) because we are looking at the
            molecules which are exactly same in terms of the bonds and atoms determined by the
            Fingerprint
            </summary>
            <param name="molecule1"></param>
            <param name="molecule2"></param>
            <param name="shouldMatchBonds"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.MakeAtomsMapOfBondsMap(System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes sourceAtom map of matching atoms out of sourceAtom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
            </summary>
            <param name="rMapList">The list produced by the getMap method.</param>
            <param name="graph1">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="graph2">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on graph1. This is sourceAtom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.MakeAtomsMapOfBondsMapSingleBond(System.Collections.Generic.IReadOnlyList{NCDK.SMSD.Algorithms.RGraphs.CDKRMap},NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
             This makes atom map of matching atoms out of atom map of matching bonds as produced by the Get(Subgraph|Ismorphism)Map methods.
             Added by Asad since CDK one doesn't pick up the correct changes
            </summary>
            <param name="list">The list produced by the getMap method.</param>
            <param name="sourceGraph">first molecule. Must not be an IQueryAtomContainer.</param>
            <param name="targetGraph">second molecule. May be an IQueryAtomContainer.</param>
            <returns>The mapping found projected on sourceGraph. This is atom List of CDKRMap objects containing Ids of matching atoms.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.Mappings">
            <summary>
            mapping solutions
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRMapHandler.IsTimedOut">
            <summary>
            true if a time out occurred else false
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKRNode">
            <summary>
             Node of the resolution graphe (RGraph) An CDKRNode represents an association
             betwwen two edges of the source graphs G1 and G2 that are compared. Two
             edges may be associated if they have at least one common feature. The
             association is defined outside this class. The node keeps tracks of the ID
             of the mapped edges (in an CDKRMap), of its neighbours in the RGraph it belongs
             to and of the set of incompatible nodes (nodes that may not be along with
             this node in the same solution)
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRNode.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for the RNode object
            </summary>
            <param name="id1">number of the bond in the graph 1</param>
            <param name="id2">number of the bond in the graph 2</param>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRNode.Extension">
            <summary>
            the extension attribute of the RNode object
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRNode.Forbidden">
            <summary>
            the forbidden attribute of the RNode object
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKRNode.ToString">
            <summary>
            Returns a string representation of the RNode
            </summary>
            <returns>the string representation of the RNode</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.RGraphs.CDKRNode.RMap">
            <summary>
            resolution map/graph
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.RGraphs.CDKSubGraphHandler">
            <summary>
            This class acts as a handler class for <see cref="T:NCDK.SMSD.Algorithms.RGraphs.CDKMCS"/> algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.RGraphs.CDKSubGraphHandler.#ctor">
            <summary>
            Creates a new instance of MappingHandler
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Singles.SingleMapping">
            <summary>
            This class handles single atom mapping.
            Either query and/or target molecule with single atom is mapped by this class.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Singles.SingleMapping.#ctor">
            <summary>
            Default
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Singles.SingleMapping.GetOverLaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns single mapping solutions.
            </summary>
            <returns>Mappings</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.Singles.SingleMapping.GetOverLaps(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Returns single mapping solutions.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.Singles.SingleMappingHandler">
            <summary>
            This is a handler class for single atom mapping <see cref="T:NCDK.SMSD.Algorithms.Singles.SingleMapping"/>.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.EdgeBuilder">
            <summary>
            Class for building/storing edges (bonds) in the graph with bond
            query capabilities.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder">
            <summary>
            Class for building/storing nodes (atoms) in the graph with atom
            query capabilities.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder.#ctor(NCDK.SMSD.Algorithms.Matchers.IVFAtomMatcher)">
            <summary>
            Construct a node for a query atom
            <param name="matcher"></param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties">
            <summary>
            Class for building/storing nodes (atoms) in the graph with atom
            query capabilities.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder">
            <summary>
            Class for parsing and generating query graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.#ctor">
            <summary>
            Constructor for VF Query Builder
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.GetNode(NCDK.IAtom)">
            <summary>
            Return a node for a given atom else return null
            </summary>
            <param name="atom"></param>
            <returns>Node in the graph for a given atom</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.AddNode(NCDK.SMSD.Algorithms.Matchers.IVFAtomMatcher,NCDK.IAtom)">
            <summary>
            Add and return a node for a query atom
            </summary>
            <returns>added Node</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Builder.VFQueryBuilder.Connect(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.Matchers.IVFBondMatcher)">
            <summary>
            Construct and return an edge for a given query and target node
            </summary>
            <returns>connected edges</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IEdge">
            <summary>
            Interface for the Edges (bonds) in graph.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.Source">
            <summary>
            Returns source Node.
            </summary>
            <returns>source node.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.Target">
            <summary>
            Returns target Node.
            </summary>
            <returns>target Node.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IEdge.BondMatcher">
            <summary>
            Returns bond matcher.
            </summary>
            <returns>Query Bond.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IMapper">
            <summary>
            Interface for the mappings (mapped objects).
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.HasMap(NCDK.IAtomContainer)">
            <summary>
            checks if a map exits for a molecule.
            </summary>
            <param name="molecule">molecule</param>
            <returns>true/false.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.CountMaps(NCDK.IAtomContainer)">
            <summary>
            Returns solution map count.
            </summary>
            <param name="target">target molecule.</param>
            <returns>map count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetMaps(NCDK.IAtomContainer)">
            <summary>
            Returns all solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get maps.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetFirstMap(NCDK.IAtomContainer)">
            <summary>
            Returns first solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get first map.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            checks if a map exits for a molecule.
            </summary>
            <param name="molecule">molecule</param>
            <returns>true/false.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.CountMaps(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns solution map count.
            </summary>
            <param name="target">target molecule.</param>
            <returns>map count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetMaps(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns all solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get maps.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IMapper.GetFirstMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Returns first solution map.
            </summary>
            <param name="target">molecule.</param>
            <returns>get first map.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.INode">
            <summary>
            Interface for the Node (atomss) in graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.CountNeighbors">
            <summary>
            Returns Neighbors count.
            <returns>Neighbors count.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.Neighbors">
            <summary>
            Returns neighbors.
            <returns>Iterable INode.</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.INode.AtomMatcher">
            <summary>
            Returns Query Atom.
            <returns>Query Atom.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.GetEdges">
            <summary>
            Returns List of Edges.
            <returns>edges.</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.AddEdge(NCDK.SMSD.Algorithms.VFLib.Builder.EdgeBuilder)">
            <summary>
            Adds edge to the edge list.
            <param name="edge">add an edge.</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.INode.AddNeighbor(NCDK.SMSD.Algorithms.VFLib.Builder.NodeBuilder)">
            <summary>
            Adds neighbor to the Neighbors List.
            <param name="node">add a node.</param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IQuery">
            <summary>
            Interface for the query molecule/graph.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.Nodes">
            <summary>
            Returns nodes of the query.
            </summary>
            <returns>node Iterable.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetNode(System.Int32)">
            <summary>
            Returns a node of the query mol at a given position.
            </summary>
            <param name="index">at position.</param>
            <returns>node.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.Edges">
            <summary>
            Returns edges of the query.
            </summary>
            <returns>edge Iterable.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetEdge(System.Int32)">
            <summary>
            Returns an edge of the query mol at a given position.
            </summary>
            <param name="index">at position.</param>
            <returns>edge</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetAtom(NCDK.SMSD.Algorithms.VFLib.INode)">
            <summary>
            Returns an atom associated with this node.
            </summary>
            <param name="node">get Atom of this node.</param>
            <returns>atom of this node</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.GetEdge(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.SMSD.Algorithms.VFLib.INode)">
            <summary>
            Returns an edge associated between two nodes.
            </summary>
            <param name="source">get an between source.</param>
            <param name="target">and target.</param>
            <returns>IEdge egde between source and target.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.CountEdges">
            <summary>
            Returns edge count.
            </summary>
            <returns>edge count.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQuery.CountNodes">
            <summary>
            Returns node count.
            </summary>
            <returns>node count.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IQueryCompiler">
            <summary>
            Interface for the query graph generator.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IQueryCompiler.Compile">
            <summary>
            Parse and build a query graph from the query moleucle.
            </summary>
            <returns>compile the query molecule and build the graph.</returns>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.IState">
            <summary>
            Interface for the storing the states of the mapping in the VF algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.GetMap">
            <summary>
            Returns the current mapping of query atoms onto target atoms.
            This map is shared among all states obtained through nextState.
            </summary>
            <returns>the current mapping of query atoms onto target atoms</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.HasNextCandidate">
            <summary>
            Returns true if another candidate match can be found or
            false otherwise.
            </summary>
            <returns>true if another candidate mapping can be found or
            false otherwise.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.NextCandidate">
            <summary>
            Returns the next candidate match.
            </summary>
            <returns>the next candidate match.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.IsMatchFeasible(NCDK.SMSD.Algorithms.VFLib.Map.Match)">
            <summary>
            Returns true if the given match will work with the current
            map, or false otherwise.
            </summary>
            <param name="match">the match to consider</param>
            <returns>true if the given match will work with the current
            map, or false otherwise.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IState.IsGoal">
            <summary>
            Returns true if all atoms in the query molecule have been
            mapped.
            </summary>
            <returns>true if all atoms in the query molecule have been
            mapped.</returns>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.IState.IsDead">
            <summary>
            Returns true if no match will come from this IState.
            </summary>
            <returns>true if no match will come from this IState</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.NextState(NCDK.SMSD.Algorithms.VFLib.Map.Match)">
            <summary>
            Returns a state in which the atoms in match have been
            added to the current mapping.
            </summary>
            <param name="match">the match to consider.</param>
            <returns>a state in which the atoms in match have been
            added to the current mapping.</returns>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.IState.BackTrack">
            <summary>
            Returns this IState's atom map to its original condition.
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.Match">
            <summary>
            Holds matching query and target nodes.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.Match.#ctor(NCDK.SMSD.Algorithms.VFLib.INode,NCDK.IAtom)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Map.Match.QueryNode">
            <summary>
            query node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Map.Match.TargetAtom">
            <summary>
            Target Atom
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper">
            <summary>
            This class finds MCS between query and target molecules
            using VF2 algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.GetTimeOut">
            <summary>
            <returns>the timeout</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.GetTimeManager">
            <summary>
            <returns>the timeManager</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.SetTimeManager(NCDK.SMSD.Tools.TimeManager)">
            <summary>
            </summary>
            <param name="aTimeManager">the timeManager to set</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.HasMap(NCDK.IAtomContainer)">
            <inheritdoc/>
            <param name="targetMolecule">targetMolecule graph</param>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <inheritdoc/>
            <param name="targetMolecule">targetMolecule graph</param>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper">
            <summary>
            This class finds MCS between query and target molecules
            using VF2 algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.GetTimeOut">
            <summary>
            <returns>the timeout</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.HasMap(NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper.HasMap(NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Map.VFState">
            <summary>
            This class finds mapping states between query and target
            molecules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Map.VFState.#ctor(NCDK.SMSD.Algorithms.VFLib.IQuery,NCDK.SMSD.Algorithms.VFLib.Builder.TargetProperties)">
            <summary>
            Initialise the VFState with query and target
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler">
            <summary>
            This class creates an template for MCS/substructure query.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.#ctor(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Construct query object from the molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.#ctor(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Construct query object from the molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.SetMolecule(NCDK.IAtomContainer)">
            <summary>
            Set Molecule
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.SetQueryMolecule(NCDK.Isomorphisms.Matchers.IQueryAtomContainer)">
            <summary>
            Set Molecule
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.Molecule">
            <summary>
            Return molecule
            <returns>Atom Container</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Algorithms.VFLib.Query.QueryCompiler.IsBondMatchFlag">
            <summary>
            <returns>the shouldMatchBonds</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler">
             <summary>
             This class should be used to find MCS between query
             graph and target graph.
            
             First the algorithm runs VF lib <see cref="T:NCDK.SMSD.Algorithms.VFLib.Map.VFMCSMapper"/>
             and reports MCS between
             run query and target graphs. Then these solutions are extended
             using McGregor <see cref="T:NCDK.SMSD.Algorithms.McGregors.McGregor"/>
             algorithm where ever required.
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler.Set(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler">
            <summary>
            This is an ultra fast method to report if query
            is a substructure for target molecule. If this case is true
            then it returns only all mapping.
            </summary>
            <remarks>
            <para>
            This is much faster than <see cref="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler"/> class
            as it only reports first match and backtracks.
            </para>
            <para>
            This class should only be used to report if a query
            graph is a substructure of the target graph.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibSubStructureHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler">
            <summary>
            This is an ultra fast method to report if query
            is a substructure for target molecule. If this case is true
            then it returns only one mapping.
            </summary>
            <remarks>
            <para>
            This is much faster than <see cref="T:NCDK.SMSD.Algorithms.VFLib.VFlibMCSHandler"/> class
            as it only reports first match and backtracks.
            </para>
            <para>
            This class should only be used to report if a query
            graph is a substructure of the target graph.
            </para>
            </remarks>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler.#ctor">
            <summary>
            Constructor for an extended VF Algorithm for the MCS search
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Algorithms.VFLib.VFlibTurboHandler.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary> 
            Set the VFLib MCS software
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Filters.ChemicalFilters">
            <summary>
            Class that ranks MCS final solution according to the chemical rules.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.#ctor(System.Collections.Generic.IList{System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Int32}},System.Collections.Generic.IList{System.Collections.Generic.IReadOnlyDictionary{NCDK.IAtom,NCDK.IAtom}},System.Collections.Generic.IDictionary{System.Int32,System.Int32},System.Collections.Generic.IDictionary{NCDK.IAtom,NCDK.IAtom},NCDK.IAtomContainer,NCDK.IAtomContainer)">
             <summary>
             This class has all the three chemical filters supported by the SMSD.
             i.e ring matches, bond energy etc
            
             <list type="bullet">
             <item>a: Bond energy,</item>
             <item>b: Fragment count,</item>
             <item>c: Stereo matches</item>
             </list> 
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByStereoAndBondMatch">
            <summary>
            Sort MCS solution by stereo and bond type matches.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByFragments">
            <summary>
            Sort solution by ascending order of the fragment count.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.SortResultsByEnergies">
            <summary>
            Sort MCS solution by bond breaking energy.
            </summary>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetSortedEnergy">
            <summary>
            Return sorted energy in ascending order.
            <returns>sorted bond breaking energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetSortedFragment">
            <summary>
            Return sorted fragment in ascending order of the size.
            <returns>sorted fragment count</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.GetStereoMatches">
            <summary>
            Return Stereo matches in descending order.
            <returns>sorted stereo matches</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertOrder(System.Double)">
            <summary>
            Get bond order value as <see cref="T:NCDK.BondOrder"/>
            </summary>
            <param name="srcOrder">numerical bond order</param>
            <returns>the bond order type for the given numerical bond order</returns>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertBondOrder(NCDK.IBond)">
            <summary>
            Get bond order value as <see cref="T:System.Int32"/> value.
            </summary>
            <param name="bond">The <see cref="T:NCDK.IBond"/> for which the order is returned.</param>
            <returns>1 for a single bond, 2 for a double bond, 3 for a triple bond, 4 for a quadruple bond,
                         and 0 for any other bond type.</returns>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertBondStereo(NCDK.IBond)">
            <summary>
            Get stereo value as integer
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.ChemicalFilters.ConvertStereo(System.Int32)">
            <summary>
            Get stereo value as Stereo enum
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Filters.PostFilter">
            <summary>
            Class that cleans redundant mappings from the solution set.
            <list type="bullet">
            <item>1: Stereo match, bond type, ring etc,</item>
            <item>2: Fragment size,</item>
            <item>3: Bond breaking energy</item>
            </list> 
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Filters.PostFilter.Filter(System.Collections.Generic.IList{System.Collections.Generic.IReadOnlyList{System.Int32}})">
            <summary>
            Creates a new instance of Post Filter and removes
            redundant Mapping(s).
            </summary>
            <param name="mappings"></param>
            <returns>Filtered non-redundant mappings</returns>
        </member>
        <member name="T:NCDK.SMSD.Globals.TimeOut">
            <summary>
            Class that manages MCS timeout.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Globals.TimeOut.Instance">
            <summary>
            Get Instance of the timeout. This starts the timeout counter.
            </summary>
            <returns>Instance</returns>
        </member>
        <member name="P:NCDK.SMSD.Globals.TimeOut.Time">
            <summary>
            cutoff value for time out.
            -1 for infinite and 0.23 for 23 seconds.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Globals.TimeOut.Enabled">
            <summary>
            true if timeout occures else false
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Helper.BinaryTree">
            <summary>
            Class to construct a Binary tree for McGregor search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.BinaryTree.#ctor(System.Int32)">
            <summary>
            Creates a new instance of BinaryTree.
            </summary>
            <param name="value">node value</param>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.Value">
            <summary>
            The value of the current node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.Equal">
            <summary>
            equal node
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BinaryTree.NotEqual">
            <summary>
            not equal node
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Helper.BondEnergy">
            <summary>
            Helper class defining the energy for a bond type. The bond
            type is defined as to element symbols and a bond order.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.BondEnergy.#ctor(System.String,System.String,NCDK.BondOrder,System.Int32)">
             <summary>
             Creates a new bond energy for the given elements and
             bond order.
            
             <param name="symbol1">element symbol for the first atom</param>
             <param name="symbol2">element symbol for the second atom</param>
             <param name="order">bond order</param>
             <param name="energy">energy for this bond type</param>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.SymbolFirstAtom">
             <summary>
             Returns the element symbol of the first atom.
            
             <returns>the element symbol as <see cref="T:System.String"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.SymbolSecondAtom">
             <summary>
             Returns the element symbol of the second atom.
            
             <returns>the element symbol as <see cref="T:System.String"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.BondOrder">
             <summary>
             Returns the bond order for this bond type energy.
            
             <returns>the bond order of the bond type as <see cref="T:NCDK.BondOrder"/></returns>
             </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.BondEnergy.Energy">
            <summary>
            Returns the energy for this bond type.
            </summary>
            <returns>the bond energy as integer.</returns>
        </member>
        <member name="T:NCDK.SMSD.Helper.FinalMappings">
            <summary>
            Class that stores raw Mapping(s) after each algorithm is executed.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.FinalMappings.Instance">
            <summary>
            Stores mapping solutions
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.FinalMappings.Set(System.Collections.Generic.IList{System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Int32}})">
            <summary>
            <inheritdoc/>
            </summary>
            <param name="list">list of mappings</param>
        </member>
        <member name="P:NCDK.SMSD.Helper.FinalMappings.Count">
            <inheritdoc/>
        </member>
        <member name="T:NCDK.SMSD.Helper.LabelContainer">
            <summary>
            Class that handles atoms and assignes an integer lable to them.
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Helper.LabelContainer.Instance">
            <summary>
            Create ids from atom labels
            </summary>
            <returns>instance of this object</returns>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.Add(System.String)">
            <summary>
            Add label if its not present
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.GetLabelID(System.String)">
            <summary>
            Returns label ID
            </summary>
            <param name="label"></param>
            <returns>labelID</returns>
        </member>
        <member name="M:NCDK.SMSD.Helper.LabelContainer.GetLabel(System.Int32)">
            <summary>
            Returns Label of a given ID
            </summary>
            <param name="labelID"></param>
            <returns>label</returns>
        </member>
        <member name="P:NCDK.SMSD.Helper.LabelContainer.Count">
            <summary>
            Returns label count
            </summary>
            <returns>size of the labels</returns>
        </member>
        <member name="T:NCDK.SMSD.IFinalMapping">
            <summary>
            Interface for mappings.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Add(System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Int32})">
            <summary>
            Adds mapping to the mapping list
            </summary>
            <param name="mapping">List of all MCS mapping between a given
            reactant and product</param>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Set(System.Collections.Generic.IList{System.Collections.Generic.IReadOnlyDictionary{System.Int32,System.Int32}})">
            <summary>
            Sets mapping list
            <param name="list">List of all MCS mapping between a given
            reactant and product</param>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.Clear">
            <summary>
            clear the mapping
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IFinalMapping.GetFinalMapping">
            <summary>
            Returns the stored mappings
            </summary>
            <returns>get of MCS mapping List</returns>
        </member>
        <member name="P:NCDK.SMSD.IFinalMapping.Count">
            <summary>
            Returns number of stored mappings
            </summary>
            <returns>size of the mapping</returns>
        </member>
        <member name="T:NCDK.SMSD.IMCSBase">
            <summary>
            Interface that holds basic core interface for all MCS algorithm.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.Set(NCDK.SMSD.Tools.MolHandler,NCDK.SMSD.Tools.MolHandler)">
            <summary>
            Initialise the query and target molecule.
            </summary>
            <param name="source">source molecule</param>
            <param name="target">target molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.Set(NCDK.Isomorphisms.Matchers.IQueryAtomContainer,NCDK.IAtomContainer)">
            <summary>
            Initialise the query and target molecule.
            </summary>
            <param name="source">source molecule</param>
            <param name="target">target molecule</param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetAllAtomMapping">
            <summary>
            Returns all plausible mappings between query and target molecules.
            Each map in the list has atom-atom equivalence of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule
            </summary>
            <returns>All possible MCS atom Mappings</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetAllMapping">
            <summary>
            Returns all plausible mappings between query and target molecules.
            Each map in the list has atom-atom equivalence index of the mappings
            between query and target molecule i.e. map.Key for the query
            and map.Value for the target molecule
            </summary>
            <returns>All possible MCS Mapping Index</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetFirstAtomMapping">
            <summary>
            Returns one of the best matches with atoms mapped.
            </summary>
            <returns>Best Atom Mapping</returns>
        </member>
        <member name="M:NCDK.SMSD.IMCSBase.GetFirstMapping">
            <summary>
            Returns one of the best matches with atom indexes mapped.
            </summary>
            <returns>Best Mapping Index</returns>
        </member>
        <member name="T:NCDK.SMSD.Isomorphism">
             <summary>
              This class implements the Isomorphism- a multipurpose structure comparison tool.
             </summary>
             <remarks>
             <para>
             It allows users to, i) find the maximal common Substructure(s) (MCS);
             ii) perform the mapping of a substructure in another structure, and;
             iii) map two isomorphic structures.</para>
             <para>It also comes with various published algorithms. The user is free to
             choose his favorite algorithm to perform MCS or substructure search.
             For example 0: Isomorphism algorithm, 1: MCSPlus, 2: VFLibMCS, 3: CDKMCS, 4:
             Substructure</para>
            
             <para>It also has a set of robust chemical filters (i.e. bond energy, fragment
             count, stereo &amp; bond match) to sort the reported MCS solutions in a chemically
             relevant manner. Each comparison can be made with or without using the bond
             sensitive mode and with implicit or explicit hydrogens.</para>
            
             <para>If you are using <b>Isomorphism, please cite Rahman <i>et.al. 2009</i></b>
             <token>cdk-cite-SMSD2009</token>. The Isomorphism algorithm is described in this paper.
             </para>
             </remarks>
             <example>
             <para>An example for <b>Substructure search</b>:</para>
             <code>                SmilesParser sp = new SmilesParser();
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //Turbo mode search
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.SubStructure, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(false, false, false);
                if (comparison.IsSubgraph())
                {
                    //Get similarity score
                    Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                    Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                    //Get Modified AtomContainer
                    IAtomContainer Mol1 = comparison.ReactantMolecule;
                    IAtomContainer Mol2 = comparison.ProductMolecule;
                    // Print the mapping between molecules
                    Console.Out.WriteLine(" Mappings: ");
                    foreach (var mapping in comparison.GetFirstMapping())
                    {
                        Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                        IAtom eAtom = Mol1.Atoms[mapping.Key];
                        IAtom pAtom = Mol2.Atoms[mapping.Value];
                        Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                    }
                    Console.Out.WriteLine("");
                }
</code>
             <para>An example for <b>MCS search</b>:</para>
             <code>                SmilesParser sp = new SmilesParser();
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //{ 0: Default Isomorphism Algorithm, 1: MCSPlus Algorithm, 2: VFLibMCS Algorithm, 3: CDKMCS Algorithm}
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.Default, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(true, true, true);

                //Get similarity score
                Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                //Get Modified AtomContainer
                IAtomContainer Mol1 = comparison.ReactantMolecule;
                IAtomContainer Mol2 = comparison.ProductMolecule;
                // Print the mapping between molecules
                Console.Out.WriteLine(" Mappings: ");
                foreach (var mapping in comparison.GetFirstMapping())
                {
                    Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                    IAtom eAtom = Mol1.Atoms[mapping.Key];
                    IAtom pAtom = Mol2.Atoms[mapping.Value];
                    Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                }
                Console.Out.WriteLine("");
</code>
             </example>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.#ctor(NCDK.SMSD.Algorithm,System.Boolean)">
            <summary>
            This is the algorithm factory and entry port for all the MCS algorithm in the Isomorphism
            supported algorithm <see cref="T:NCDK.SMSD.Algorithm"/> types:
            <list type="bullet">
            <item>0: Default,</item>
            <item>1: MCSPlus,</item>
            <item>2: VFLibMCS,</item>
            <item>3: CDKMCS,</item>
            <item>4: SubStructure</item>
            </list> 
            </summary>
            <param name="algorithmType"><see cref="T:NCDK.SMSD.Algorithm"/></param>
            <param name="bondTypeFlag"></param>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.MakeBondMapsOfAtomMaps(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IReadOnlyList{System.Collections.Generic.IReadOnlyDictionary{NCDK.IAtom,NCDK.IAtom}})">
            <summary>
            Returns bond maps between source and target molecules based on the atoms
            <param name="ac1">source molecule</param>
            <param name="ac2">target molecule</param>
            <param name="mappings">mappings between source and target molecule atoms</param>
            <returns>bond maps between source and target molecules based on the atoms</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.MakeBondMapOfAtomMap(NCDK.IAtomContainer,NCDK.IAtomContainer,System.Collections.Generic.IReadOnlyDictionary{NCDK.IAtom,NCDK.IAtom})">
             <summary>
            
             Returns bond map between source and target molecules based on the atoms
             <param name="ac1">source molecule</param>
             <param name="ac2">target molecule</param>
             <param name="mapping">mappings between source and target molecule atoms</param>
             <returns>bond map between source and target molecules based on the atoms</returns>
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.Init(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Initialize the query and targetAtomCount mol via mol files
            </summary>
            <param name="sourceMolFileName">source mol file name</param>
            <param name="targetMolFileName">target mol file name</param>
            <param name="removeHydrogen">set true to make hydrogens implicit before search</param>
            <param name="cleanAndConfigureMolecule"> eg: percieveAtomTypesAndConfigureAtoms, detect aromaticity etc</param>
        </member>
        <member name="P:NCDK.SMSD.Isomorphism.BondSensitiveTimeOut">
            <summary>
            <inheritdoc/> (default 0.15 min)
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Isomorphism.BondInSensitiveTimeOut">
            <summary>
            <inheritdoc/> (default 1.00 min)
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Isomorphism.SetFirstBondMap(System.Collections.Generic.IReadOnlyDictionary{NCDK.IBond,NCDK.IBond})">
            <summary>
            
            </summary>
            <param name="firstBondMCS">The firstBondMCS to set</param>
        </member>
        <member name="F:NCDK.SMSD.Labelling.AbstractReactionLabeller.fixAtomMappingCastType">
            <summary>
            A nasty hack necessary to get around a bug in the CDK
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.AbstractReactionLabeller.CloneAndSortMappings(NCDK.IReaction,NCDK.IReaction,System.Collections.Generic.IReadOnlyDictionary{NCDK.IAtomContainer,System.Int32[]})">
            <summary>
            Clone and Sort the mappings based on the order of the first object
            in the mapping (which is assumed to be the reactant).
            </summary>
            <param name="reaction"></param>
        </member>
        <member name="M:NCDK.SMSD.Labelling.ICanonicalReactionLabeller.GetCanonicalReaction(NCDK.IReaction)">
            <summary>
            Convert a reaction into a canonical form by canonizing each of the
            structures in the reaction in turn.
            </summary>
            <param name="reaction">the <see cref="T:NCDK.IReaction"/> to be processed</param>
            <returns>the canonical <see cref="T:NCDK.IReaction"/></returns>
        </member>
        <member name="T:NCDK.SMSD.Labelling.Permutor">
            <summary>
            General permutation generator, that uses orderly generation by ranking and
            unranking. The basic idea is that all permutations of length N can be ordered
            (lexicographically) like:
            <pre>
            0 [0, 1, 2]
            1 [0, 2, 1]
            2 [1, 0, 2]
            ...
            </pre>
            where the number to the left of each permutation is the <i>rank</i> - really
            just the index in this ordered list. The list is created on demand, by a
            process called <i>unranking</i> where the rank is converted to the
            permutation that appears at that point in the list.
            </summary>
            <remarks>
            <para>The algorithms used are from the book "Combinatorial Generation :
            Algorithms, Generation, and Search" (or C.A.G.E.S.) by D.L. Kreher and D.R.
            Stinson</para>
            </remarks>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.currentRank">
            <summary>
            The current rank of the permutation to use
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.maxRank">
            <summary>
            The maximum rank possible, given the size
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.size">
            <summary>
            The number of objects to permute
            </summary>
        </member>
        <member name="F:NCDK.SMSD.Labelling.Permutor.random">
            <summary>
            For accessing part of the permutation space
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.#ctor(System.Int32)">
            <summary>
            Create a permutor that will generate permutations of numbers up to 
            <paramref name="size"/>.
            </summary>
            <param name="size">the size of the permutations to generate</param>
        </member>
        <member name="P:NCDK.SMSD.Labelling.Permutor.Rank">
            <summary>
            the permutation to use, given its rank.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.SetPermutation(System.Int32[])">
            <summary>
            Set the currently used permutation.
            </summary>
            <param name="permutation">the permutation to use, as an int array</param>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetRandomNextPermutation">
            <summary>
            Randomly skip ahead in the list of permutations.
            </summary>
            <returns>a permutation in the range (current, N!)</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetNextPermutation">
            <summary>
            Get the next permutation in the list.
            </summary>
            <returns>the next permutation</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.GetCurrentPermutation">
            <summary>
            Get the permutation that is currently being used.
            </summary>
            <returns>the permutation as an int array</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.CalculateMaxRank">
            <summary>
            Calculate the max possible rank for permutations of N numbers.
            </summary>
            <returns>the maximum number of permutations</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.RankPermutationLexicographically(System.Int32[])">
            <summary>
            Convert a permutation (in the form of an int array) into a 'rank' - which
            is just a single number that is the order of the permutation in a lexico-
            graphically ordered list.
            </summary>
            <param name="permutation">the permutation to use</param>
            <returns>the rank as a number</returns>
        </member>
        <member name="M:NCDK.SMSD.Labelling.Permutor.UnrankPermutationLexicographically(System.Int32,System.Int32)">
            <summary>
            Performs the opposite to the rank method, producing the permutation that
            has the order <paramref name="rank"/> in the lexicographically ordered list.
            </summary>
            <remarks>
            As an implementation note, the algorithm assumes that the permutation is
            in the form [1,...N] not the more usual [0,...N-1] for a list of size N.
            This is why there is the final step of 'shifting' the permutation. The
            shift also reduces the numbers by one to make them array indices.
            </remarks>
            <param name="rank">the order of the permutation to generate</param>
            <param name="size">the length/size of the permutation</param>
            <returns>a permutation as an int array</returns>
        </member>
        <member name="T:NCDK.SMSD.Rings.HanserRingFinder">
             <summary>
             Finds the Set of all Rings. This is an implementation of the algorithm
             published in <token>cdk-cite-HAN96</token>. Some of the comments refer to pseudo code
             fragments listed in this article. The concept is that a regular molecular
             graph is first converted into a path graph (refer PathGraph.java),
             i.e. a graph where the edges are actually paths. This can list several
             nodes that are implicitly connecting the two nodes between the path
             is formed (refer PathEdge.java).
            
             The paths that join source and sink node are step by step fused and the joined
             nodes are deleted from the path graph (collapsed path). What remains is a graph
             of paths that have the same start and endpoint and are thus rings (source=sink=ring).
             </summary>
        </member>
        <member name="M:NCDK.SMSD.Rings.HanserRingFinder.FindRings(NCDK.IAtomContainer)">
            <summary>
            Returns a collection of rings.
            </summary>
            <param name="molecule"></param>
            <returns>a <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.IList`1"/>s containing one ring each</returns>
            <seealso cref="M:NCDK.SMSD.Rings.IRingFinder.FindRings(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.SMSD.Rings.HanserRingFinder.GetRingSet(NCDK.IAtomContainer)">
            <summary>
            Returns Ring set based on Hanser Ring Finding method
            <param name="molecule"></param>
            </summary>
            <returns>report collected the rings</returns>
            <seealso cref="M:NCDK.SMSD.Rings.IRingFinder.GetRingSet(NCDK.IAtomContainer)"/>
        </member>
        <member name="M:NCDK.SMSD.Rings.IRingFinder.FindRings(NCDK.IAtomContainer)">
            <summary>
            Returns Collection of atoms in Rings based on Hanser Ring Finding method
            <param name="molecule"></param>
            <returns>report collected the rings</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Rings.IRingFinder.GetRingSet(NCDK.IAtomContainer)">
            <summary>
            Returns CDK object Ring set based on Hanser Ring Finding method
            </summary>
            <param name="molecule"></param>
            <returns>report collected the rings</returns>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Tools.BondEnergies">
             <summary>
             Class that stores bond breaking/formation energy between two atoms.
             </summary>
             <remarks>
             Reference: Huheey, pps. A-21 to A-34; T.L. Cottrell,
             "The Strengths of Chemical Bonds," 2nd ed., Butterworths, London, 1958;
             B. deB. Darwent, "National Standard Reference Data Series,
             "National Bureau of Standards, No. 31, Washington, DC, 1970;
             S.W. Benson, J. Chem. Educ., 42, 502 (1965).
            
             Common Bond Energies (D) and Bond Lengths (r)
            
             Hydrogen
             Bond    D(kJ/mol) r(pm)
            
             H-H    432    74
             H-B    389    119
             H-C    411    109
             H-Si    318    148
             H-Ge    288    153
             H-Sn    251    170
             H-N    386    101
             H-P    322    144
             H-As    247    152
             H-O    459    96
             H-S    363    134
             H-Se    276    146
             H-Te    238    170
             H-F    565    92
             H-Cl    428    127
             H-Br    362    141
             H-I    295    161
            
            
             Group 13
             Bond    D(kJ/mol) r(pm)
             B-B    293
             B-O    536
             B-F    613
             B-Cl    456    175
             B-Br    377
            
            
             Group 14
             Bond    D(kJ/mol) r(pm)
             C-C    346    154
             C=C    602    134
             C#C    835    120
             C-Si    318    185
             C-Ge    238    195
             C-Sn    192    216
             C-Pb    130    230
             C-N    305    147
             C=N    615    129
             C#N    887    116
             C-P    264    184
             C-O    358    143
             C=O    799    120
             C#O    1072    113
             C-B    356
             C-S    272    182
             C=S    573    160
             C-F    485    135
             C-Cl    327    177
             C-Br    285    194
             C-I    213    214
            
            
             Group 14
             Bond    D(kJ/mol) r(pm)
             Si-Si    222    233
             Si-N    355
             Si-O    452    163
             Si-S    293    200
             Si-F    565    160
             Si-Cl    381    202
             Si-Br    310    215
             Si-I    234    243
             Ge-Ge    188    241
             Ge-N    257
             Ge-F    470    168
             Ge-Cl    349    210
             Ge-Br    276    230
             Ge-I    212
             Sn-F    414
             Sn-Cl    323    233
             Sn-Br    273    250
             Sn-I    205    270
             Pb-F    331
             Pb-Cl    243    242
             Pb-Br    201
             Pb-I    142    279
            
            
             Group 15
             Bond    D(kJ/mol) r(pm)
             N-N    167    145
             N=N    418    125
             N#N    942    110
             N-O    201    140
             N=O    607    121
             N-F    283    136
             N-Cl    313    175
             P-P    201    221
             P-O    335    163
             P=O    544    150
             P=S    335    186
             P-F    490    154
             P-Cl    326    203
             P-Br    264
             P-I    184
             As-As    146    243
             As-O    301    178
             As-F    484    171
             As-Cl    322    216
             As-Br    458    233
             As-I    200    254
             Sb-Sb    121
             Sb-F    440
             Sb-Cl (SbCl5)    248
             Sb-Cl (SbCl3)    315    232
            
             Group 16
             Bond    D(kJ/mol) r(pm)
             O-O    142    148
             O=O    494    121
             O-F    190    142
             S=O    522    143
             S-S (S8)    226    205
             S=S    425    149
             S-F    284    156
             S-Cl    255    207
             Se-Se    172
             Se=Se    272    215
            
             Group 17
             Bond    D(kJ/mol) r(pm))
             F-F    155    142
             Cl-Cl    240    199
             Br-Br    190    228
             I-I    148    267
             At-At    116
             I-O    201
             I-F    273    191
             I-Cl    208    232
             I-Br    175
            
             Group 18
             Bond    D(kJ/mol) r(pm)
             Kr-F (KrF2)    50    190
             Xe-O    84    175
             Xe-F    130    195
             </remarks>
        </member>
        <member name="P:NCDK.SMSD.Tools.BondEnergies.Instance">
            <summary>
            Singleton pattern instance for the Bond Energy class
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(NCDK.IAtom,NCDK.IAtom,NCDK.BondOrder)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="sourceAtom">First bondEnergy</param>
            <param name="targetAtom">Second bondEnergy</param>
            <param name="bondOrder">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(System.String,System.String,NCDK.BondOrder)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="sourceAtom">First bondEnergy</param>
            <param name="targetAtom">Second bondEnergy</param>
            <param name="bondOrder">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.BondEnergies.GetEnergies(NCDK.IBond)">
            <summary>
            Returns bond energy for a bond type, given atoms and bond type
            <param name="bond">(single, double etc)</param>
            <returns>bond energy</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.ExtAtomContainerManipulator">
            <summary>
            Class that handles some customised features for SMSD atom containers.
            <para>This is an extension of CDK AtomContainer.
            Some part of this code was taken from CDK source code and modified.</para>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.MakeDeepCopy(NCDK.IAtomContainer)">
            <summary>
            Retrurns deep copy of the molecule
            </summary>
            <param name="container"></param>
            <returns>deep copy of the mol</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.AromatizeMolecule(NCDK.IAtomContainer)">
            <summary>
            This function finds rings and uses aromaticity detection code to
            aromatize the molecule.
            </summary>
            <param name="mol">input molecule</param>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetExplicitHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            Returns The number of explicit hydrogens for a given IAtom.
            </summary>
            <param name="atomContainer"></param>
            <param name="atom"></param>
            <returns>The number of explicit hydrogens on the given IAtom.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetImplicitHydrogenCount(NCDK.IAtom)">
            <summary>
            Returns The number of Implicit Hydrogen Count for a given IAtom.
            </summary>
            <param name="atom"></param>
            <returns>Implicit Hydrogen Count</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.GetHydrogenCount(NCDK.IAtomContainer,NCDK.IAtom)">
            <summary>
            The summed implicit + explicit hydrogens of the given IAtom.
            </summary>
            <param name="atomContainer"></param>
            <param name="atom"></param>
            <returns>The summed implicit + explicit hydrogens of the given IAtom.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.RemoveHydrogensExceptSingleAndPreserveAtomID(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <param name="atomContainer"></param>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.ConvertExplicitToImplicitHydrogens(NCDK.IAtomContainer)">
            <summary>
            Returns IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which
            is atom Hydrogen then its not removed.
            </summary>
            <param name="atomContainer"></param>
            <returns>IAtomContainer without Hydrogen. If an AtomContainer has atom single atom which is atom Hydrogen then its not removed.</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.ExtAtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(NCDK.IAtomContainer)">
            <summary>
            Convenience method to perceive atom types for all <see cref="T:NCDK.IAtom"/>s in the
            <see cref="T:NCDK.IAtomContainer"/>, using the <see cref="T:NCDK.AtomTypes.CDKAtomTypeMatcher"/>. If the
            matcher finds atom matching atom type, the <see cref="T:NCDK.IAtom"/> will be configured
            to have the same properties as the <see cref="T:NCDK.IAtomType"/>. If no matching atom
            type is found, no configuration is performed.
            </summary>
            <param name="container"></param>
            <exception cref="T:NCDK.CDKException"></exception>
        </member>
        <member name="T:NCDK.SMSD.Tools.MoleculeSanityCheck">
            <summary>
            Class that cleans a molecule before MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.MoleculeSanityCheck.CheckAndCleanMolecule(NCDK.IAtomContainer)">
            <summary>
            Modules for cleaning a molecule
            </summary>
            <param name="molecule"></param>
            <returns>cleaned AtomContainer</returns>
        </member>
        <member name="M:NCDK.SMSD.Tools.MoleculeSanityCheck.Configure(NCDK.IAtomContainer)">
            <summary>
            Fixes Aromaticity of the molecule
            i.e. need to find rings and aromaticity again since added H's
            <param name="mol"></param>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.MolHandler">
            <summary>
            Class that handles molecules for MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.MolHandler.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of MolHandler
            </summary>
            <param name="molFile">atomContainer file name</param>
        </member>
        <member name="M:NCDK.SMSD.Tools.MolHandler.#ctor(NCDK.IAtomContainer,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance of MolHandler
            <param name="container">Molecule AtomContainer</param>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Tools.MolHandler.Molecule">
            <summary>
            Returns the modified container
            <returns>get processed / modified container</returns>
            </summary>
        </member>
        <member name="P:NCDK.SMSD.Tools.MolHandler.RemoveHydrogenFlag">
            <summary>
            Returns true if hydrogens were made implicit else return false
            <returns>true if remove H else false</returns>
            </summary>
        </member>
        <member name="T:NCDK.SMSD.Tools.TimeManager">
            <summary>
            Class that handles execution time of the MCS search.
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.#ctor">
            <summary>
            Constructor for storing execution time
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInHours">
            <summary>
            Returns Elapsed Time In Hours
            <returns>Elapsed Time In Hours</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInMinutes">
            <summary>
            Returns Elapsed Time In Minutes
            <returns>Elapsed Time In Minutes</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInSeconds">
            <summary>
            Return Elapsed Time In Seconds
            <returns>Elapsed Time In Seconds</returns>
            </summary>
        </member>
        <member name="M:NCDK.SMSD.Tools.TimeManager.GetElapsedTimeInMilliSeconds">
            <summary>
            Returns Elapsed Time In Mill Seconds
            <returns>Elapsed Time In Mill Seconds</returns>
            </summary>
        </member>
        <member name="T:NCDK.Tools.AtomTypeTools">
            <summary>
            AtomTypeTools is a helper class for assigning atom types to an atom.
            </summary>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.AssignAtomTypePropertiesToAtom(NCDK.IAtomContainer,System.Boolean)">
            <summary>
            Method assigns certain properties to an atom. Necessary for the atom type matching
            Properties:
            <list type="bullet">
              <item>aromaticity</item>
              <item>ChemicalGroup (CDKChemicalRingGroupConstant)</item>
              <item>
                <item>SSSR</item>
                <item>Ring/Group, ringSize, aromaticity</item>
                <item>SphericalMatcher (HoSe Code)</item>
              </item>
            </list>
            </summary>
            <param name="molecule"></param>
            <param name="aromaticity"><see langword="true"/> if aromaticity should be calculated</param>
            <returns>sssrf ring set of the molecule</returns>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.GetSubgraphSmiles(NCDK.IAtomContainer,NCDK.IAtomContainer)">
            <summary>
            New SMILES code respects atom valency hence a ring subgraph of 'o1cccc1CCCC' is correctly
            written as 'o1ccc[c]1' note there is no hydrogen there since it was an external attachment.
            To get unique subgraph SMILES we need to adjust valencies of atoms by adding Hydrogens. We
            base this on the sum of bond orders removed.
            </summary>
            <param name="subgraph">subgraph (atom and bond refs in 'molecule')</param>
            <param name="molecule">the molecule</param>
            <returns>the canonical smiles of the subgraph</returns>
            <exception cref="T:NCDK.CDKException">something went wrong with SMILES gen</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.Cansmi(NCDK.IAtomContainer)">
            <summary>
            Canonical SMILES for the provided molecule.
            </summary>
            <param name="mol">molecule</param>
            <returns>the cansmi string</returns>
            <exception cref="T:NCDK.CDKException">something went wrong with SMILES gen</exception>
        </member>
        <member name="M:NCDK.Tools.AtomTypeTools.RingSystemClassifier(NCDK.IRing,System.String)">
            <summary>
             Identifies ringSystem and returns a number which corresponds to
             CDKChemicalRingConstant
            </summary>
            <param name="ring">Ring class with the ring system</param>
            <param name="smile">smile of the ring system</param>
            <returns>chemicalRingConstant</returns>
        </member>
        <member name="T:NCDK.Tools.CDKUtilities">
            <summary>
            Utility class written by Todd Martin, for help in his QSAR descriptors and SMILES
            parser. Seems to have overlap with, at least, cdk.normalize.Normalizer.
            </summary>
            <para>TODO: merge with Normalizer.</para>
            <seealso cref="T:NCDK.Normalizers.Normalizer"/>
        </member>
    </members>
</doc>
